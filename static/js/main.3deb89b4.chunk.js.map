{"version":3,"sources":["Constants/enums.ts","Components/GridItem/GridItem.tsx","Classes/PathAlgorithm.ts","Classes/DijkstraAlgorithm.ts","Classes/BinaryMinHeapKV.ts","Classes/AStarAlgorithm.ts","Classes/Pathfinder.ts","Containers/Grid/Grid.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["GRID_ITEM_STATUS","PATH_ALGORITHM","GridItem","row","column","weight","index","status","displayWeight","onChange","onMouseEnterGridItem","onMouseDownGridItem","onMouseUpGridItem","onTouchMove","onTouchEnd","className","START","END","EXPLORED","EXPLORING","PATH","WALL","getClassNameFromStatus","onMouseEnter","onMouseDown","onMouseUp","data-index","htmlFor","id","type","value","min","PathAlgorithm","data","nodes","start","end","rows","columns","path","pathNodeArray","pathStepArray","pathStepCurrent","this","map","i","distance","prevNode","undefined","neighbours","y","Math","floor","x","push","pathNodes","pathNode","reverse","DijkstraAlgorithm","calcPath","createNodeArray","unvisited","forEach","item","Infinity","cNode","getNodeNeighbours","cDistance","cIndex","includes","splice","indexOf","buildPathArray","smallestDistIndex","buildCurrentStep","length","nextNode","stepNodes","node","OPEN","BinaryMinHeapKV","heap","getParent","getLeft","parent","getRight","swap","index1","index2","t","isKeyALessThanB","indexA","indexB","key","siftDown","left","right","lowerIndex","insert","heapData","swapRecursive","extractMin","pop","isEmpty","containsValue","some","AStarAlgorithm","endX","endY","getEndXY","getHeuristic","abs","greedy","closedNodes","Set","gScore","Array","fill","fScore","minHeap","currentNodeIndex","currentNode","add","neighbourIndex","has","newGScore","Pathfinder","pathAlgorithm","getDataObject","algorithm","alg","ASTAR_GREEDY","ASTAR","getNextPathStep","Grid","props","resetPathState","resetNodes","setState","state","pathStep","generateGridItems","gridItems","onChangeNodeWeight","onTouchMoveGridItem","onTouchEndGridItem","e","newNodes","parseInt","target","getGridStyles","style","getGridTemplate","Object","assign","calcGridHeightAndWidth","width","height","templateColumns","gridTemplateColumns","onCalculatePath","pathfinder","getPathNodes","onCalculatePathSteps","DisplayPathSteps","wait","ms","Promise","res","setTimeout","onChangeAlgorithm","stopDragAt","dragStartIndex","dragStartInitialWeight","isCreatingWalls","isDragging","dragEndIndex","stopDrag","startDragAt","continueDragAt","onMouseExitGrid","el","document","elementFromPoint","touches","clientX","clientY","getAttribute","DIJKSTRA","prevProps","steps","getPathStepsLength","onMouseLeave","onClick","React","Component","App","useState","setRows","setColumns","margin","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3deb89b4.chunk.js","sourcesContent":["export enum GRID_ITEM_STATUS {\r\n  OPEN = 1,\r\n  WALL,\r\n  START,\r\n  END,\r\n  PATH,\r\n  EXPLORED,\r\n  EXPLORING\r\n}\r\n\r\nexport enum PATH_ALGORITHM {\r\n  DIJKSTRA = 1,\r\n  ASTAR,\r\n  ASTAR_GREEDY\r\n}\r\n","import React from \"react\";\r\n\r\nimport \"./GridItem.css\";\r\nimport { GRID_ITEM_STATUS } from \"../../Constants/enums\";\r\n\r\ntype GridItemProps = {\r\n  row: number;\r\n  column: number;\r\n  weight: number;\r\n  index: number;\r\n  status: GRID_ITEM_STATUS;\r\n  displayWeight: boolean;\r\n  onChange: (index: number) => React.ChangeEventHandler<HTMLInputElement>;\r\n  onMouseEnterGridItem: (index: number) => React.MouseEventHandler;\r\n  onMouseDownGridItem: (index: number) => React.MouseEventHandler;\r\n  onMouseUpGridItem: (index: number) => React.MouseEventHandler;\r\n  onTouchMove: React.TouchEventHandler;\r\n  onTouchEnd: React.TouchEventHandler;\r\n};\r\n\r\nconst GridItem = ({\r\n  row,\r\n  column,\r\n  weight,\r\n  index,\r\n  status,\r\n  displayWeight,\r\n  onChange,\r\n  onMouseEnterGridItem,\r\n  onMouseDownGridItem,\r\n  onMouseUpGridItem,\r\n  onTouchMove,\r\n  onTouchEnd\r\n}: GridItemProps) => {\r\n  const getClassNameFromStatus = (status: GRID_ITEM_STATUS, weight: number) => {\r\n    let className = \"grid__item\";\r\n    switch (status) {\r\n      case GRID_ITEM_STATUS.START:\r\n        return (className += \" grid__item--start\");\r\n      case GRID_ITEM_STATUS.END:\r\n        return (className += \" grid__item--end\");\r\n      case GRID_ITEM_STATUS.EXPLORED:\r\n        return (className += \" grid__item--explored\");\r\n      case GRID_ITEM_STATUS.EXPLORING:\r\n        return (className += \" grid__item--exploring\");\r\n      case GRID_ITEM_STATUS.PATH:\r\n        return (className += \" grid__item--path\");\r\n      case GRID_ITEM_STATUS.WALL:\r\n        return (className += \" grid__item--wall\");\r\n      default:\r\n        return className;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={getClassNameFromStatus(status, weight)}\r\n      onMouseEnter={onMouseEnterGridItem(index)}\r\n      onMouseDown={onMouseDownGridItem(index)}\r\n      onMouseUp={onMouseUpGridItem(index)}\r\n      onTouchMove={onTouchMove}\r\n      onTouchEnd={onTouchEnd}\r\n      data-index={index}\r\n    >\r\n      <p className=\"item__index\">i:{index}</p>\r\n      {displayWeight && (\r\n        <div className=\"item__data\">\r\n          <label htmlFor=\"weight-input\">W:</label>\r\n          <input\r\n            id=\"weight-input\"\r\n            className=\"item__input\"\r\n            type=\"number\"\r\n            value={weight}\r\n            onChange={onChange(index)}\r\n            min={0}\r\n          />\r\n        </div>\r\n      )}\r\n      <p className=\"item__coords\">({column + \",\" + row})</p>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GridItem;\r\n","import { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport type pathNode = {\r\n  i: number;\r\n  distance: number;\r\n  weight: number;\r\n  prevNode?: number;\r\n};\r\n\r\nexport type pathData = {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n};\r\n\r\nexport class PathAlgorithm {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n  pathNodeArray: pathNode[];\r\n  pathStepArray: [GRID_ITEM_STATUS[]];\r\n  pathStepCurrent: number;\r\n  constructor(data: pathData) {\r\n    this.nodes = data.nodes;\r\n    this.rows = data.rows;\r\n    this.columns = data.columns;\r\n    this.start = data.start;\r\n    this.end = data.end;\r\n    this.path = [];\r\n    this.pathNodeArray = [];\r\n    this.pathStepArray = [[]];\r\n    this.pathStepCurrent = 0;\r\n  }\r\n\r\n  /**\r\n   * Creates the array of pathNode's\r\n   * @param nodes array of nodes with weights\r\n   * @returns array of pathNode's\r\n   */\r\n  createNodeArray(nodes: number[]) {\r\n    let nodeArray: pathNode[] = nodes.map((value, i) => {\r\n      return { i, distance: 0, weight: value, prevNode: undefined };\r\n    });\r\n    //  console.log(\"INITIAL\");\r\n    //  console.log(nodeArray[5].prevNode);\r\n    // console.log(\"--INITIAL--\");\r\n    return nodeArray;\r\n  }\r\n\r\n  /**\r\n   * Gets the indexes of the nodes neighbours.\r\n   * @param index index of node to get neighbours for.\r\n   * @returns array of neighbours by index\r\n   */\r\n  getNodeNeighbours(index: number) {\r\n    let { rows, columns } = this;\r\n    let neighbours = [];\r\n    // x & y values:\r\n    let y = Math.floor(index / columns);\r\n    let x = index - y * columns;\r\n    // right & left neighbors\r\n    if (x - 1 >= 0) {\r\n      neighbours.push(index - 1);\r\n    }\r\n    if (x + 1 < columns) {\r\n      neighbours.push(index + 1);\r\n    }\r\n    // up / down neighbors\r\n    if (y - 1 >= 0) {\r\n      neighbours.push(index - columns);\r\n    }\r\n    if (y + 1 < rows) {\r\n      neighbours.push(index + columns);\r\n    }\r\n    return neighbours;\r\n  }\r\n\r\n  /**\r\n   * Builds the array of the path taken to reach the end node.\r\n   * @param pathNodes array containing the calculated path data\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  buildPathArray(pathNodes: pathNode[]) {\r\n    let path = [];\r\n    let pathNode = pathNodes[this.end];\r\n    while (pathNode.prevNode !== undefined) {\r\n      path.push(pathNode.i);\r\n      pathNode = pathNodes[pathNode.prevNode];\r\n    }\r\n    path.push(pathNode.i);\r\n    path.reverse();\r\n    this.path = path;\r\n    this.pathStepCurrent = 0;\r\n    return path;\r\n  }\r\n\r\n  getNextPathStep() {\r\n    if (this.pathStepArray[this.pathStepCurrent + 1]) {\r\n      this.pathStepCurrent += 1;\r\n      return this.pathStepArray[this.pathStepCurrent];\r\n    }\r\n    return this.pathStepArray[this.pathStepCurrent];\r\n  }\r\n}\r\n","import { PathAlgorithm, pathNode } from \"./PathAlgorithm\";\r\nimport { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport class DijkstraAlgorithm extends PathAlgorithm {\r\n  /**\r\n   * Calculates path using Dijkstra's Algorithm\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath = () => {\r\n    let { start, end, nodes } = this;\r\n    let pathNodes: pathNode[] = this.createNodeArray(nodes);\r\n    // Dijkstra's Algorithm\r\n    // Create a set of unvisited nodes called the unvisited set.\r\n    //let unvisited = new Set<number>();\r\n    let unvisited: number[] = [];\r\n    pathNodes.forEach((item, index) => {\r\n      // assign to every node a tentative distance value\r\n      // 0 for the start node, infinity for all other nodes.\r\n      if (start === index) {\r\n        item.distance = 0;\r\n      } else {\r\n        item.distance = Infinity;\r\n      }\r\n      unvisited.push(index);\r\n    });\r\n    // Set the initial node as the current node\r\n    let cNode = pathNodes[start];\r\n    while (unvisited.length > 0) {\r\n      // For the current node, go through all of it's neighbors.\r\n      let neighbours = this.getNodeNeighbours(cNode.i);\r\n      // These also prevent the esLint no-loop-func error.\r\n      let cDistance = cNode.distance;\r\n      let cIndex = cNode.i;\r\n      neighbours.forEach(index => {\r\n        // consider only unvisited neighbours. (that also aren't walls)\r\n        if (unvisited.includes(index) && pathNodes[index].weight !== 0) {\r\n          // Calculate tentative distance through the current node\r\n          let distance = pathNodes[index].weight + cDistance;\r\n          // Compare the tentative distance to the current assigned distance\r\n          // and assign the smaller one, and set the prevNode index so we can keep the path as well.\r\n          if (pathNodes[index].distance > distance) {\r\n            pathNodes[index].distance = distance;\r\n            pathNodes[index].prevNode = cIndex;\r\n          }\r\n        }\r\n      });\r\n\r\n      // Mark the current node as visited by removing it from the unvisited set.\r\n      unvisited.splice(unvisited.indexOf(cNode.i), 1);\r\n      // If destination node has been visited, then stop.\r\n      if (!unvisited.includes(end)) {\r\n        //this.buildCurrentStep(pathNodes);\r\n        this.pathNodeArray = pathNodes;\r\n        return this.buildPathArray(pathNodes);\r\n      }\r\n      // end will be infinity if it hasn't been found yet,\r\n      // so we can use it to find the next lowest distance node.\r\n      let smallestDistIndex = end; // prevents no-loop-func EsLint error that occurs if you directly use cNode.\r\n      unvisited.forEach(index => {\r\n        // select unvisited node with the smallest distance as current node.\r\n        if (pathNodes[index].distance < pathNodes[smallestDistIndex].distance) {\r\n          smallestDistIndex = index;\r\n        }\r\n      });\r\n      cNode = pathNodes[smallestDistIndex];\r\n\r\n      this.buildCurrentStep(pathNodes, unvisited, cNode);\r\n      // if the smallest distance is infinity still, there is no path, so end.\r\n      if (cNode.distance === Infinity) {\r\n        return [];\r\n      }\r\n    }\r\n    return [];\r\n  };\r\n\r\n  buildCurrentStep(\r\n    pathNodes: pathNode[],\r\n    unvisited: number[],\r\n    nextNode: pathNode\r\n  ) {\r\n    let stepNodes: GRID_ITEM_STATUS[] = pathNodes.map((node, index) => {\r\n      if (node.weight === 0) {\r\n        return GRID_ITEM_STATUS.WALL;\r\n      } else if (node.prevNode !== undefined && unvisited.includes(index)) {\r\n        return GRID_ITEM_STATUS.EXPLORING;\r\n      } else if (node.prevNode !== undefined) {\r\n        return GRID_ITEM_STATUS.EXPLORED;\r\n      }\r\n      return GRID_ITEM_STATUS.OPEN;\r\n    });\r\n\r\n    this.pathStepArray.push(stepNodes);\r\n  }\r\n}\r\n","export interface HeapData {\r\n  key: number;\r\n  value: number;\r\n}\r\n\r\n/**\r\n * Binary min kvheap\r\n * @param key keys are used to sort the array.\r\n * @param value values are stored with the key.\r\n */\r\nexport class BinaryMinHeapKV {\r\n  heap: HeapData[];\r\n  constructor() {\r\n    this.heap = [];\r\n  }\r\n\r\n  /**\r\n   * Gets parent index\r\n   * @param index\r\n   * @returns {number} parent index\r\n   */\r\n  private getParent = (index: number) => {\r\n    return Math.floor((index - 1) / 2);\r\n  };\r\n\r\n  /**\r\n   * Get index of left child of parent\r\n   * @param parent parent index\r\n   * @returns {number} left child index\r\n   */\r\n  private getLeft = (parent: number) => {\r\n    return parent * 2 + 1;\r\n  };\r\n\r\n  /**\r\n   * Get index for right child of parent\r\n   * @param parent parent index\r\n   * @returns {number} right child index\r\n   */\r\n  private getRight = (parent: number) => {\r\n    return parent * 2 + 2;\r\n  };\r\n\r\n  /**\r\n   * Swaps index1 and index2 in the heap.\r\n   * @param index1 index of heap to swap\r\n   * @param index2 index of heap to swap\r\n   */\r\n  private swap = (index1: number, index2: number) => {\r\n    let t = this.heap[index1];\r\n    this.heap[index1] = this.heap[index2];\r\n    this.heap[index2] = t;\r\n  };\r\n\r\n  /**\r\n   * Determines whether key of indexA is less than key of indexB\r\n   * @param indexA index of heap\r\n   * @param indexB index of heap to compare to\r\n   * @returns {boolean} true if A.key < B.key otherwise false.\r\n   */\r\n  private isKeyALessThanB = (indexA: number, indexB: number) => {\r\n    if (this.heap[indexA].key < this.heap[indexB].key) {\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Recursively sifts down HeapData at index until min heap is preserved\r\n   * @param index index of heap to sift down\r\n   */\r\n  private siftDown = (index: number) => {\r\n    let { heap, getLeft, getRight, isKeyALessThanB, siftDown, swap } = this;\r\n    if (index >= 0) {\r\n      let left = getLeft(index);\r\n      let right = getRight(index);\r\n      // have to check if they are undefined before comparisons.\r\n      if (heap[left] && heap[right]) {\r\n        // need to make sure at least one of them is lower before we swap...\r\n        if (isKeyALessThanB(left, index) || isKeyALessThanB(right, index)) {\r\n          // will swap right with index if left === right.\r\n          let lowerIndex = isKeyALessThanB(left, right) ? left : right;\r\n          swap(lowerIndex, index);\r\n          siftDown(lowerIndex);\r\n        }\r\n      } else if (heap[left] && isKeyALessThanB(left, index)) {\r\n        swap(left, index);\r\n        siftDown(left);\r\n      } else if (heap[right] && isKeyALessThanB(right, index)) {\r\n        swap(right, index);\r\n        siftDown(right);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Inserts key, value into binary min heap.\r\n   * @param key number used to sort binary minheap\r\n   * @param value number also stored with key.\r\n   */\r\n  public insert = (key: number, value: number) => {\r\n    let heapData: HeapData = { key: key, value: value };\r\n    this.heap.push(heapData);\r\n\r\n    let swapRecursive = (index: number) => {\r\n      let parent = this.getParent(index);\r\n      if (parent >= 0 && this.heap[parent].key > this.heap[index].key) {\r\n        this.swap(index, parent);\r\n        swapRecursive(parent);\r\n      }\r\n    };\r\n    swapRecursive(this.heap.length - 1);\r\n  };\r\n\r\n  /**\r\n   * Removes and returns the minimum value of the heap\r\n   * @returns {HeapData} {key: number, value: number} of minimum of heap.\r\n   */\r\n  public extractMin = () => {\r\n    let { heap, siftDown } = this;\r\n    let min = {\r\n      key: heap[0].key,\r\n      value: heap[0].value\r\n    };\r\n    // replace first element with last element.\r\n    heap[0] = heap[heap.length - 1];\r\n    // remove last element from heap.\r\n    heap.pop();\r\n    // sift down the first element.\r\n    siftDown(0);\r\n    return min;\r\n  };\r\n\r\n  /**\r\n   * Determines if the minheap is empty\r\n   * @returns {boolean} true or false\r\n   */\r\n  public isEmpty = () => {\r\n    if (this.heap.length > 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Determines whether value is in the heap\r\n   * @param value Value stored with key\r\n   * @returns {boolean} true or false\r\n   */\r\n  public containsValue = (value: number) => {\r\n    return this.heap.some(item => item.value === value);\r\n  };\r\n}\r\n","import { PathAlgorithm, pathNode, pathData } from \"./PathAlgorithm\";\r\nimport { BinaryMinHeapKV } from \"./BinaryMinHeapKV\";\r\nimport { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport class AStarAlgorithm extends PathAlgorithm {\r\n  endX: number;\r\n  endY: number;\r\n\r\n  constructor(data: pathData) {\r\n    super(data);\r\n\r\n    let { endX, endY } = this.getEndXY();\r\n    this.endX = endX;\r\n    this.endY = endY;\r\n  }\r\n\r\n  /**\r\n   * Calculates path using the A* algorithm.\r\n   * @param greedy Should path calculation use the greedy algorithm\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath(greedy: boolean = false) {\r\n    let { start, end, nodes } = this;\r\n    let pathNodes: pathNode[] = this.createNodeArray(nodes);\r\n\r\n    // nodes that have been explored\r\n    let closedNodes = new Set<number>();\r\n\r\n    // the cost of the cheapest path from start to n currently known\r\n    let gScore: number[] = new Array(pathNodes.length).fill(Infinity);\r\n    gScore[start] = 0;\r\n\r\n    // fScore[n] = gScores[n] + heuristic(n)\r\n    let fScore = [...gScore];\r\n    fScore[start] = this.getHeuristic(start);\r\n\r\n    // min heap of nodes that can still be explored\r\n    let minHeap = new BinaryMinHeapKV();\r\n    minHeap.insert(this.getHeuristic(start), start);\r\n\r\n    while (!minHeap.isEmpty()) {\r\n      // get lowest fscore node in minheap.\r\n      let currentNodeIndex = minHeap.extractMin().value;\r\n      let currentNode = pathNodes[currentNodeIndex];\r\n      if (currentNode.i === end) {\r\n        this.pathNodeArray = pathNodes;\r\n        return this.buildPathArray(pathNodes);\r\n      }\r\n\r\n      closedNodes.add(currentNodeIndex);\r\n      let neighbours = this.getNodeNeighbours(currentNode.i);\r\n      neighbours.forEach(neighbourIndex => {\r\n        if (closedNodes.has(neighbourIndex)) {\r\n          return;\r\n        }\r\n        // if it's not a wall.\r\n        if (pathNodes[neighbourIndex].weight !== 0) {\r\n          // Calculate a new gScore.\r\n          let newGScore =\r\n            gScore[currentNodeIndex] + pathNodes[neighbourIndex].weight;\r\n          if (newGScore < gScore[neighbourIndex]) {\r\n            // Update gscore, fScore, prevNode, and add to the openNodes array.\r\n            pathNodes[neighbourIndex].prevNode = currentNodeIndex;\r\n            gScore[neighbourIndex] = newGScore;\r\n\r\n            if (!greedy) {\r\n              // non-greedy cares about the weight to the node as well.\r\n              fScore[neighbourIndex] =\r\n                newGScore + this.getHeuristic(neighbourIndex);\r\n            } else {\r\n              // greedy only cares about the heuristic, and its weight\r\n              fScore[neighbourIndex] = this.getHeuristic(neighbourIndex);\r\n            }\r\n\r\n            // Don't need to check if minheap already contains the neighbour\r\n            // can just re-insert it instead of updating key / re-heapifying\r\n            // as it will be added to closedNodes if it's the lowest, and never added again.\r\n\r\n            minHeap.insert(fScore[neighbourIndex], neighbourIndex);\r\n            this.buildCurrentStep(closedNodes, pathNodes);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Get end's x,y position for use in algorithm.\r\n   * @returns object with endX and endY properties\r\n   */\r\n  getEndXY = () => {\r\n    let endY = Math.floor(this.end / this.columns);\r\n    let endX = this.end - endY * this.columns;\r\n    return { endX, endY };\r\n  };\r\n\r\n  /**\r\n   * Calculates the heuristic for the current index in a* algorithm by manhattan distance\r\n   * @returns Manhattan distance from index to end position.\r\n   */\r\n  getHeuristic = (index: number) => {\r\n    let y = Math.floor(index / this.columns);\r\n    let x = index - y * this.columns;\r\n    return Math.abs(this.endY - y) + Math.abs(this.endX - x);\r\n  };\r\n\r\n  buildCurrentStep(closedNodes: Set<number>, pathNodes: pathNode[]) {\r\n    let stepNodes: GRID_ITEM_STATUS[] = pathNodes.map((node, index) => {\r\n      if (node.weight === 0) {\r\n        return GRID_ITEM_STATUS.WALL;\r\n      }\r\n      if (node.prevNode !== undefined && closedNodes.has(index)) {\r\n        return GRID_ITEM_STATUS.EXPLORED;\r\n      } else if (node.prevNode !== undefined) {\r\n        return GRID_ITEM_STATUS.EXPLORING;\r\n      }\r\n      return GRID_ITEM_STATUS.OPEN;\r\n    });\r\n    this.pathStepArray.push(stepNodes);\r\n  }\r\n}\r\n","import { PATH_ALGORITHM } from \"../Constants/enums\";\r\nimport { DijkstraAlgorithm } from \"./DijkstraAlgorithm\";\r\nimport { AStarAlgorithm } from \"./AStarAlgorithm\";\r\nimport { PathAlgorithm } from \"./PathAlgorithm\";\r\n\r\nexport class Pathfinder {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n  pathAlgorithm: PathAlgorithm;\r\n  constructor(\r\n    nodes: number[],\r\n    rows: number,\r\n    columns: number,\r\n    start: number,\r\n    end: number\r\n  ) {\r\n    this.nodes = nodes;\r\n    this.rows = rows;\r\n    this.columns = columns;\r\n    this.start = start;\r\n    this.end = end;\r\n    this.path = [];\r\n    this.pathAlgorithm = new PathAlgorithm(this.getDataObject());\r\n  }\r\n\r\n  private getDataObject = () => {\r\n    return {\r\n      nodes: this.nodes,\r\n      rows: this.rows,\r\n      columns: this.columns,\r\n      start: this.start,\r\n      end: this.end,\r\n      path: []\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Calculates and returns the path for the specified algorithm\r\n   * @param [algorithm] Type of algorithm to use\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath(algorithm?: PATH_ALGORITHM) {\r\n    let data = this.getDataObject();\r\n    let alg;\r\n    switch (algorithm) {\r\n      case PATH_ALGORITHM.ASTAR_GREEDY:\r\n        alg = new AStarAlgorithm(data);\r\n        this.path = alg.calcPath(true);\r\n        break;\r\n      case PATH_ALGORITHM.ASTAR:\r\n        alg = new AStarAlgorithm(data);\r\n        this.path = alg.calcPath();\r\n        break;\r\n      default:\r\n        alg = new DijkstraAlgorithm(data);\r\n        this.path = alg.calcPath();\r\n        break;\r\n    }\r\n    this.pathAlgorithm = alg;\r\n    return this.path;\r\n  }\r\n\r\n  getPathNodes() {\r\n    return this.pathAlgorithm.pathNodeArray;\r\n  }\r\n\r\n  getPathSteps() {\r\n    return this.pathAlgorithm.pathStepArray;\r\n  }\r\n\r\n  getPathStepsLength() {\r\n    return this.pathAlgorithm.pathStepArray.length;\r\n  }\r\n\r\n  getNextPathStep() {\r\n    return this.pathAlgorithm.getNextPathStep();\r\n  }\r\n}\r\n","import React, { ChangeEvent } from \"react\";\r\n\r\nimport GridItem from \"../../Components/GridItem/GridItem\";\r\nimport { GRID_ITEM_STATUS, PATH_ALGORITHM } from \"../../Constants/enums\";\r\n\r\nimport \"./Grid.css\";\r\nimport { Pathfinder } from \"../../Classes/Pathfinder\";\r\nimport { pathNode } from \"../../Classes/PathAlgorithm\";\r\n\r\ntype GridProps = {\r\n  rows: number;\r\n  columns: number;\r\n};\r\n\r\n/**\r\n * @param nodes Nodes of the grid, 0 is not-walkable (ie a wall), all other values are the weight of going to that node.\r\n */\r\ntype GridState = {\r\n  nodes: number[];\r\n  path: number[];\r\n  algorithm: PATH_ALGORITHM;\r\n  isDragging: boolean;\r\n  isCreatingWalls: boolean;\r\n  dragStartIndex: number;\r\n  dragStartInitialWeight: number;\r\n  dragEndIndex: number;\r\n  pathNodes: pathNode[];\r\n  pathStep: GRID_ITEM_STATUS[];\r\n};\r\n\r\nclass Grid extends React.Component<GridProps, GridState> {\r\n  constructor(props: GridProps) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      /** Nodes of the grid, 0 is not-walkable (ie a wall), all other values are the weight of going to that node. */\r\n      nodes: new Array(props.rows * props.columns).fill(1),\r\n      path: [],\r\n      algorithm: PATH_ALGORITHM.DIJKSTRA,\r\n      isDragging: false,\r\n      isCreatingWalls: false,\r\n      dragStartInitialWeight: 0,\r\n      dragStartIndex: 0,\r\n      dragEndIndex: 0,\r\n      pathNodes: [],\r\n      pathStep: new Array(props.rows * props.columns).fill(\r\n        GRID_ITEM_STATUS.OPEN\r\n      )\r\n    };\r\n    this.state.pathStep[0] = GRID_ITEM_STATUS.START;\r\n    this.state.pathStep[this.state.pathStep.length - 1] = GRID_ITEM_STATUS.END;\r\n  }\r\n\r\n  componentDidUpdate(prevProps: GridProps) {\r\n    if (\r\n      this.props.columns !== prevProps.columns ||\r\n      this.props.rows !== prevProps.rows\r\n    ) {\r\n      this.resetPathState(true);\r\n    }\r\n  }\r\n\r\n  resetPathState = (resetNodes = false) => {\r\n    this.setState({\r\n      nodes: resetNodes\r\n        ? new Array(this.props.rows * this.props.columns).fill(1)\r\n        : this.state.nodes,\r\n      path: [],\r\n      pathNodes: [],\r\n      pathStep: []\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Generates grid items\r\n   * @param rows Number of rows to create\r\n   * @param columns Number of columns to create\r\n   * @returns array of grid__item 's\r\n   */\r\n  generateGridItems = (\r\n    rows: number,\r\n    columns: number,\r\n    nodes = this.state.nodes\r\n  ) => {\r\n    let gridItems = [];\r\n    for (let y = 0; y < rows; y++) {\r\n      for (let x = 0; x < columns; x++) {\r\n        let i = y * columns + x;\r\n        let status = this.state.pathStep[i];\r\n        if (this.state.path.includes(i)) {\r\n          status = GRID_ITEM_STATUS.PATH;\r\n        }\r\n        if (nodes[i] === 0) {\r\n          status = GRID_ITEM_STATUS.WALL;\r\n        }\r\n        if (x === 0 && y === 0) {\r\n          status = GRID_ITEM_STATUS.START;\r\n        }\r\n        if (x === columns - 1 && y === rows - 1) {\r\n          status = GRID_ITEM_STATUS.END;\r\n        }\r\n        gridItems.push(\r\n          <div className=\"item__container--square\" key={\"ics\" + x + \"_\" + y}>\r\n            <GridItem\r\n              status={status}\r\n              key={\"gi_\" + x + \"_\" + y}\r\n              row={y}\r\n              column={x}\r\n              weight={nodes[y * columns + x] ? nodes[y * columns + x] : 0}\r\n              index={y * columns + x}\r\n              displayWeight={columns > 7 && rows > 7 ? false : true}\r\n              onChange={this.onChangeNodeWeight}\r\n              onMouseEnterGridItem={this.onMouseEnterGridItem}\r\n              onMouseDownGridItem={this.onMouseDownGridItem}\r\n              onMouseUpGridItem={this.onMouseUpGridItem}\r\n              onTouchMove={this.onTouchMoveGridItem}\r\n              onTouchEnd={this.onTouchEndGridItem}\r\n            />\r\n          </div>\r\n        );\r\n      }\r\n    }\r\n    return gridItems;\r\n  };\r\n\r\n  /**\r\n   * Changes node at index to e.target.value\r\n   * @param index index of element in nodes array\r\n   */\r\n  onChangeNodeWeight = (index: number) => (\r\n    e: React.ChangeEvent<HTMLInputElement>\r\n  ) => {\r\n    let newNodes = [...this.state.nodes];\r\n    newNodes[index] = parseInt(e.target.value);\r\n    this.setState({ nodes: newNodes });\r\n  };\r\n\r\n  /**\r\n   * Gets grid styles\r\n   * @param rows number of rows\r\n   * @param columns number of columns\r\n   * @returns  React.CSSProperties { width, height, gridTemplateColumns, gridTemplateRows }\r\n   */\r\n  getGridStyles = (rows: number, columns: number) => {\r\n    let style = this.getGridTemplate(columns);\r\n    Object.assign(style, this.calcGridHeightAndWidth(rows, columns));\r\n    return style;\r\n  };\r\n\r\n  /**\r\n   * Calcs grid height and width\r\n   * @param rows numbers of rows\r\n   * @param columns number of columns\r\n   * @returns React.CSSProperties { width: value, height: value } as % of it's container to keep each grid item a square.\r\n   */\r\n  calcGridHeightAndWidth = (rows: number, columns: number) => {\r\n    let width = 100;\r\n    let height = 100;\r\n    if (rows > columns) {\r\n      width = (columns / rows) * 100;\r\n    } else {\r\n      height = (rows / columns) * 100;\r\n    }\r\n    let gridWidth: React.CSSProperties = {\r\n      width: width + \"%\",\r\n      height: height + \"%\"\r\n    };\r\n    return gridWidth;\r\n  };\r\n\r\n  /**\r\n   * Gets grid template\r\n   * @param columns number of columns\r\n   * @returns React.CSSProperties { gridTemplateColumns: value, gridTemplateRows: value }\r\n   */\r\n  getGridTemplate = (columns: number) => {\r\n    let templateColumns = \"\";\r\n    for (let i = 0; i < columns; i++) {\r\n      templateColumns += \"1fr \";\r\n    }\r\n    let gridTemplate: React.CSSProperties = {\r\n      gridTemplateColumns: templateColumns\r\n    };\r\n    return gridTemplate;\r\n  };\r\n\r\n  /**\r\n   * Uses pathfinder.js and the state of the grid to\r\n   * calculate a path and display it.\r\n   */\r\n  onCalculatePath = () => {\r\n    this.resetPathState();\r\n    let pathfinder = new Pathfinder(\r\n      this.state.nodes,\r\n      this.props.rows,\r\n      this.props.columns,\r\n      0,\r\n      this.state.nodes.length - 1\r\n    );\r\n    let path = pathfinder.calcPath(this.state.algorithm);\r\n    let pathNodes = pathfinder.getPathNodes();\r\n    this.setState({ path: path, pathNodes: pathNodes });\r\n  };\r\n\r\n  onCalculatePathSteps = () => {\r\n    this.resetPathState();\r\n    let pathfinder = new Pathfinder(\r\n      this.state.nodes,\r\n      this.props.rows,\r\n      this.props.columns,\r\n      0,\r\n      this.state.nodes.length - 1\r\n    );\r\n    pathfinder.calcPath(this.state.algorithm);\r\n    this.DisplayPathSteps(pathfinder);\r\n  };\r\n\r\n  async DisplayPathSteps(pathfinder: Pathfinder) {\r\n    let steps = pathfinder.getPathStepsLength();\r\n    let path = pathfinder.path;\r\n    for (let i = 0; i < steps; i++) {\r\n      this.setState({ pathStep: pathfinder.getNextPathStep() });\r\n      await this.wait(5);\r\n    }\r\n    this.setState({ path: path });\r\n  }\r\n\r\n  wait = (ms: number) => new Promise(res => setTimeout(res, ms));\r\n\r\n  /**\r\n   * Changes the algorithm state based on select elements value.\r\n   */\r\n  onChangeAlgorithm = (e: ChangeEvent<HTMLSelectElement>) => {\r\n    this.setState({ algorithm: parseInt(e.target.value) });\r\n  };\r\n\r\n  /**\r\n   * Sets is dragging to false, and the dragEndIndex to index.\r\n   * Changes the node at index to a wall or open if that nodes weight wasn't\r\n   * changed between MouseDown & MouseUp.\r\n   * @param index index of node array that mouseup event was called on.\r\n   */\r\n  stopDragAt = (index: number) => {\r\n    // it was a mouse click\r\n    if (\r\n      this.state.dragStartIndex === index &&\r\n      this.state.dragStartInitialWeight === this.state.nodes[index]\r\n    ) {\r\n      let nodes = [...this.state.nodes];\r\n      nodes[index] = this.state.isCreatingWalls ? 0 : 1;\r\n      this.setState(state => {\r\n        return {\r\n          isDragging: false,\r\n          dragEndIndex: index,\r\n          nodes: nodes\r\n        };\r\n      });\r\n    } else {\r\n      // it was actually a drag.\r\n      this.setState(state => {\r\n        return { isDragging: false, dragEndIndex: index };\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sets isdragging state to false\r\n   * Used for when mouse exits grid area on drag,\r\n   * or if touch event ends.\r\n   */\r\n  stopDrag = () => {\r\n    // Would need an index to call stopDragAt, which would need a\r\n    // last updated index state.\r\n    this.setState(state => {\r\n      return { isDragging: false };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Updates state of isDragging to true, dragStartIndex to index,\r\n   * dragStartInitialWeight to node at index's weight,\r\n   * sets isCreatingWalls state based on node at index's weight\r\n   * @param index index in node array that mousedown was called on.\r\n   */\r\n  startDragAt = (index: number) => {\r\n    this.resetPathState();\r\n    this.setState(state => {\r\n      return {\r\n        isDragging: true,\r\n        dragStartIndex: index,\r\n        dragStartInitialWeight: this.state.nodes[index],\r\n        isCreatingWalls: this.state.nodes[index] === 0 ? false : true\r\n      };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * If user is dragging, changes node weight to 0 or 1\r\n   * depending on if they started dragging on a wall or open node,\r\n   * and updates the node state.\r\n   * @param index index in node array that mouse entered\r\n   */\r\n  continueDragAt = (index: number) => {\r\n    if (this.state.isDragging) {\r\n      if (index !== this.state.dragStartIndex) {\r\n        // User is dragging, so switch between walls & open tiles.\r\n        let nodes = [...this.state.nodes];\r\n        nodes[index] = this.state.isCreatingWalls ? 0 : 1;\r\n        nodes[this.state.dragStartIndex] = nodes[index];\r\n        this.setState(state => {\r\n          return { nodes: nodes };\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Update drag state variables on mouse down.\r\n   * @param index index in node array that mousedown was called on.\r\n   */\r\n  onMouseDownGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.startDragAt(index);\r\n  };\r\n\r\n  /**\r\n   * Update drag state on mouse up.\r\n   * @param index index of node array that mouseup event was called on.\r\n   */\r\n  onMouseUpGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.stopDragAt(index);\r\n  };\r\n\r\n  /**\r\n   * Upgrade node state on mouse enter\r\n   * @param index index in node array that mouse entered\r\n   */\r\n  onMouseEnterGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.continueDragAt(index);\r\n  };\r\n\r\n  /**\r\n   * Sets state of dragging to false\r\n   */\r\n  onMouseExitGrid = (e: React.MouseEvent) => {\r\n    this.stopDrag();\r\n  };\r\n\r\n  /**\r\n   * Updates state for nodes & dragging based on element touch is over.\r\n   */\r\n  onTouchMoveGridItem = (e: React.TouchEvent) => {\r\n    let el = document.elementFromPoint(\r\n      e.touches[0].clientX,\r\n      e.touches[0].clientY\r\n    );\r\n    // need to make sure we have a valid element & valid data.\r\n    if (el !== null) {\r\n      let data = el.getAttribute(\"data-index\");\r\n      if (data !== null) {\r\n        let index = parseInt(data);\r\n        if (this.state.isDragging === false) {\r\n          this.startDragAt(index);\r\n        } else {\r\n          this.continueDragAt(index);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sets is dragging state to false.\r\n   */\r\n  onTouchEndGridItem = (e: React.TouchEvent) => {\r\n    this.stopDrag();\r\n  };\r\n\r\n  render() {\r\n    const { rows, columns } = this.props;\r\n    const { nodes } = this.state;\r\n    return (\r\n      <>\r\n        <div\r\n          className=\"grid__container\"\r\n          style={this.getGridStyles(rows, columns)}\r\n          onMouseLeave={this.onMouseExitGrid}\r\n        >\r\n          {this.generateGridItems(rows, columns, nodes)}\r\n        </div>\r\n        <button id=\"calc_path\" onClick={this.onCalculatePath}>\r\n          Calculate Path\r\n        </button>\r\n        <button id=\"calc_path_steps\" onClick={this.onCalculatePathSteps}>\r\n          Show Path Steps\r\n        </button>\r\n        <select id=\"select_algorithm\" onChange={this.onChangeAlgorithm}>\r\n          <option value={PATH_ALGORITHM.DIJKSTRA}>Dijkstra</option>\r\n          <option value={PATH_ALGORITHM.ASTAR}>A*</option>\r\n          <option value={PATH_ALGORITHM.ASTAR_GREEDY}>A* Greedy</option>\r\n        </select>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Grid;\r\n","import React, { useState } from \"react\";\r\n\r\nimport Grid from \"./Containers/Grid/Grid\";\r\n\r\nimport \"./App.css\";\r\n\r\nconst App: React.FC = () => {\r\n  const [rows, setRows] = useState(8);\r\n  const [columns, setColumns] = useState(8);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div style={{ width: \"500px\", margin: \"auto\" }}>\r\n        <Grid rows={rows} columns={columns} />\r\n        <div className=\"rc__container\">\r\n          <label htmlFor=\"rows\">Rows:</label>\r\n          <input\r\n            id=\"rows\"\r\n            className=\"rc__input\"\r\n            type=\"number\"\r\n            min={3}\r\n            value={rows}\r\n            onChange={e => setRows(parseInt(e.target.value))}\r\n          />\r\n          <label htmlFor=\"columns\">Columns:</label>\r\n          <input\r\n            id=\"rows\"\r\n            className=\"rc__input\"\r\n            type=\"number\"\r\n            min={3}\r\n            value={columns}\r\n            onChange={e => setColumns(parseInt(e.target.value))}\r\n          />\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}