{"version":3,"sources":["Constants/enums.ts","Components/GridItem/GridItem.tsx","Classes/PathAlgorithm.ts","Classes/DijkstraAlgorithm.ts","Classes/BinaryMinHeapKV.ts","Classes/AStarAlgorithm.ts","Classes/Pathfinder.ts","Containers/Grid/Grid.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["GRID_ITEM_STATUS","PATH_ALGORITHM","GridItem","row","column","weight","index","status","displayWeight","onChange","onMouseEnterGridItem","onMouseDownGridItem","onMouseUpGridItem","onTouchMove","onTouchEnd","className","START","END","EXPLORED","EXPLORING","PATH","WALL","getClassNameFromStatus","onMouseEnter","onMouseDown","onMouseUp","data-index","htmlFor","id","type","value","min","PathAlgorithm","data","nodes","start","end","rows","columns","path","pathNodeArray","pathStepArray","pathStepCurrent","this","map","i","distance","prevNode","undefined","neighbours","y","Math","floor","x","push","pathNodes","pathNode","reverse","DijkstraAlgorithm","calcPath","createNodeArray","unvisited","forEach","item","Infinity","cNode","getNodeNeighbours","cDistance","cIndex","includes","splice","indexOf","buildPathArray","smallestDistIndex","buildCurrentStep","length","nextNode","stepNodes","node","OPEN","BinaryMinHeapKV","heap","getParent","getLeft","parent","getRight","swap","index1","index2","t","isKeyALessThanB","indexA","indexB","key","siftDown","left","right","lowerIndex","insert","heapData","swapRecursive","extractMin","pop","isEmpty","containsValue","some","AStarAlgorithm","endX","endY","getEndXY","getHeuristic","abs","greedy","closedNodes","Set","gScore","Array","fill","fScore","minHeap","currentNodeIndex","currentNode","add","neighbourIndex","has","newGScore","Pathfinder","pathAlgorithm","getDataObject","algorithm","alg","ASTAR_GREEDY","ASTAR","getNextPathStep","Grid","props","resetPathState","resetNodes","setState","state","pathStep","generateGridItems","gridItems","onChangeNodeWeight","onTouchMoveGridItem","onTouchEndGridItem","e","newNodes","parseInt","target","setWaitTime","val","waitTime","getGridStyles","style","getGridTemplate","Object","assign","calcGridHeightAndWidth","width","height","templateColumns","gridTemplateColumns","onCalculatePath","pathfinder","getPathNodes","onCalculatePathSteps","DisplayPathSteps","wait","ms","Promise","res","setTimeout","onChangeAlgorithm","stopDragAt","dragStartIndex","dragStartInitialWeight","tempVal","isDragging","dragEndIndex","stopDrag","startDragAt","isCreatingWalls","continueDragAt","currentTarget","preventDefault","onMouseExitGrid","el","document","elementFromPoint","touches","clientX","clientY","getAttribute","DIJKSTRA","prevProps","steps","getPathStepsLength","onMouseLeave","onClick","React","Component","App","useState","setRows","setColumns","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bda94d32.chunk.js","sourcesContent":["export enum GRID_ITEM_STATUS {\r\n  OPEN = 1,\r\n  WALL,\r\n  START,\r\n  END,\r\n  PATH,\r\n  EXPLORED,\r\n  EXPLORING\r\n}\r\n\r\nexport enum PATH_ALGORITHM {\r\n  DIJKSTRA = 1,\r\n  ASTAR,\r\n  ASTAR_GREEDY\r\n}\r\n","import React from \"react\";\r\n\r\nimport \"./GridItem.css\";\r\nimport { GRID_ITEM_STATUS } from \"../../Constants/enums\";\r\n\r\ntype GridItemProps = {\r\n  row: number;\r\n  column: number;\r\n  weight: number;\r\n  index: number;\r\n  status: GRID_ITEM_STATUS;\r\n  displayWeight: boolean;\r\n  onChange: (index: number) => React.ChangeEventHandler<HTMLInputElement>;\r\n  onMouseEnterGridItem: (index: number) => React.MouseEventHandler;\r\n  onMouseDownGridItem: (index: number) => React.MouseEventHandler;\r\n  onMouseUpGridItem: (index: number) => React.MouseEventHandler;\r\n  onTouchMove: React.TouchEventHandler;\r\n  onTouchEnd: React.TouchEventHandler;\r\n};\r\n\r\nconst GridItem = ({\r\n  row,\r\n  column,\r\n  weight,\r\n  index,\r\n  status,\r\n  displayWeight,\r\n  onChange,\r\n  onMouseEnterGridItem,\r\n  onMouseDownGridItem,\r\n  onMouseUpGridItem,\r\n  onTouchMove,\r\n  onTouchEnd\r\n}: GridItemProps) => {\r\n  const getClassNameFromStatus = (status: GRID_ITEM_STATUS, weight: number) => {\r\n    let className = \"grid__item\";\r\n    switch (status) {\r\n      case GRID_ITEM_STATUS.START:\r\n        return (className += \" grid__item--start\");\r\n      case GRID_ITEM_STATUS.END:\r\n        return (className += \" grid__item--end\");\r\n      case GRID_ITEM_STATUS.EXPLORED:\r\n        return (className += \" grid__item--explored\");\r\n      case GRID_ITEM_STATUS.EXPLORING:\r\n        return (className += \" grid__item--exploring\");\r\n      case GRID_ITEM_STATUS.PATH:\r\n        return (className += \" grid__item--path\");\r\n      case GRID_ITEM_STATUS.WALL:\r\n        return (className += \" grid__item--wall\");\r\n      default:\r\n        return className;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={getClassNameFromStatus(status, weight)}\r\n      onMouseEnter={onMouseEnterGridItem(index)}\r\n      onMouseDown={onMouseDownGridItem(index)}\r\n      onMouseUp={onMouseUpGridItem(index)}\r\n      onTouchMove={onTouchMove}\r\n      onTouchEnd={onTouchEnd}\r\n      data-index={index}\r\n    >\r\n      <p className=\"item__index\">i:{index}</p>\r\n      {displayWeight && (\r\n        <div className=\"item__data\">\r\n          <label htmlFor=\"weight-input\">W:</label>\r\n          <input\r\n            id=\"weight-input\"\r\n            className=\"item__input\"\r\n            type=\"number\"\r\n            value={weight}\r\n            onChange={onChange(index)}\r\n            min={0}\r\n          />\r\n        </div>\r\n      )}\r\n      <p className=\"item__coords\">({column + \",\" + row})</p>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GridItem;\r\n","import { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport type pathNode = {\r\n  i: number;\r\n  distance: number;\r\n  weight: number;\r\n  prevNode?: number;\r\n};\r\n\r\nexport type pathData = {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n};\r\n\r\nexport class PathAlgorithm {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n  pathNodeArray: pathNode[];\r\n  pathStepArray: [GRID_ITEM_STATUS[]];\r\n  pathStepCurrent: number;\r\n  constructor(data: pathData) {\r\n    this.nodes = data.nodes;\r\n    this.rows = data.rows;\r\n    this.columns = data.columns;\r\n    this.start = data.start;\r\n    this.end = data.end;\r\n    this.path = [];\r\n    this.pathNodeArray = [];\r\n    this.pathStepArray = [[]];\r\n    this.pathStepCurrent = 0;\r\n  }\r\n\r\n  /**\r\n   * Creates the array of pathNode's\r\n   * @param nodes array of nodes with weights\r\n   * @returns array of pathNode's\r\n   */\r\n  createNodeArray(nodes: number[]) {\r\n    let nodeArray: pathNode[] = nodes.map((value, i) => {\r\n      return { i, distance: 0, weight: value, prevNode: undefined };\r\n    });\r\n    //  console.log(\"INITIAL\");\r\n    //  console.log(nodeArray[5].prevNode);\r\n    // console.log(\"--INITIAL--\");\r\n    return nodeArray;\r\n  }\r\n\r\n  /**\r\n   * Gets the indexes of the nodes neighbours.\r\n   * @param index index of node to get neighbours for.\r\n   * @returns array of neighbours by index\r\n   */\r\n  getNodeNeighbours(index: number) {\r\n    let { rows, columns } = this;\r\n    let neighbours = [];\r\n    // x & y values:\r\n    let y = Math.floor(index / columns);\r\n    let x = index - y * columns;\r\n    // right & left neighbors\r\n    if (x - 1 >= 0) {\r\n      neighbours.push(index - 1);\r\n    }\r\n    if (x + 1 < columns) {\r\n      neighbours.push(index + 1);\r\n    }\r\n    // up / down neighbors\r\n    if (y - 1 >= 0) {\r\n      neighbours.push(index - columns);\r\n    }\r\n    if (y + 1 < rows) {\r\n      neighbours.push(index + columns);\r\n    }\r\n    return neighbours;\r\n  }\r\n\r\n  /**\r\n   * Builds the array of the path taken to reach the end node.\r\n   * @param pathNodes array containing the calculated path data\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  buildPathArray(pathNodes: pathNode[]) {\r\n    let path = [];\r\n    let pathNode = pathNodes[this.end];\r\n    while (pathNode.prevNode !== undefined) {\r\n      path.push(pathNode.i);\r\n      pathNode = pathNodes[pathNode.prevNode];\r\n    }\r\n    path.push(pathNode.i);\r\n    path.reverse();\r\n    this.path = path;\r\n    this.pathStepCurrent = 0;\r\n    return path;\r\n  }\r\n\r\n  getNextPathStep() {\r\n    if (this.pathStepArray[this.pathStepCurrent + 1]) {\r\n      this.pathStepCurrent += 1;\r\n      return this.pathStepArray[this.pathStepCurrent];\r\n    }\r\n    return this.pathStepArray[this.pathStepCurrent];\r\n  }\r\n}\r\n","import { PathAlgorithm, pathNode } from \"./PathAlgorithm\";\r\nimport { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport class DijkstraAlgorithm extends PathAlgorithm {\r\n  /**\r\n   * Calculates path using Dijkstra's Algorithm\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath = () => {\r\n    let { start, end, nodes } = this;\r\n    let pathNodes: pathNode[] = this.createNodeArray(nodes);\r\n    // Dijkstra's Algorithm\r\n    // Create a set of unvisited nodes called the unvisited set.\r\n    //let unvisited = new Set<number>();\r\n    let unvisited: number[] = [];\r\n    pathNodes.forEach((item, index) => {\r\n      // assign to every node a tentative distance value\r\n      // 0 for the start node, infinity for all other nodes.\r\n      if (start === index) {\r\n        item.distance = 0;\r\n      } else {\r\n        item.distance = Infinity;\r\n      }\r\n      unvisited.push(index);\r\n    });\r\n    // Set the initial node as the current node\r\n    let cNode = pathNodes[start];\r\n    while (unvisited.length > 0) {\r\n      // For the current node, go through all of it's neighbors.\r\n      let neighbours = this.getNodeNeighbours(cNode.i);\r\n      // These also prevent the esLint no-loop-func error.\r\n      let cDistance = cNode.distance;\r\n      let cIndex = cNode.i;\r\n      neighbours.forEach(index => {\r\n        // consider only unvisited neighbours. (that also aren't walls)\r\n        if (unvisited.includes(index) && pathNodes[index].weight !== 0) {\r\n          // Calculate tentative distance through the current node\r\n          let distance = pathNodes[index].weight + cDistance;\r\n          // Compare the tentative distance to the current assigned distance\r\n          // and assign the smaller one, and set the prevNode index so we can keep the path as well.\r\n          if (pathNodes[index].distance > distance) {\r\n            pathNodes[index].distance = distance;\r\n            pathNodes[index].prevNode = cIndex;\r\n          }\r\n        }\r\n      });\r\n\r\n      // Mark the current node as visited by removing it from the unvisited set.\r\n      unvisited.splice(unvisited.indexOf(cNode.i), 1);\r\n      // If destination node has been visited, then stop.\r\n      if (!unvisited.includes(end)) {\r\n        //this.buildCurrentStep(pathNodes);\r\n        this.pathNodeArray = pathNodes;\r\n        return this.buildPathArray(pathNodes);\r\n      }\r\n      // end will be infinity if it hasn't been found yet,\r\n      // so we can use it to find the next lowest distance node.\r\n      let smallestDistIndex = end; // prevents no-loop-func EsLint error that occurs if you directly use cNode.\r\n      unvisited.forEach(index => {\r\n        // select unvisited node with the smallest distance as current node.\r\n        if (pathNodes[index].distance < pathNodes[smallestDistIndex].distance) {\r\n          smallestDistIndex = index;\r\n        }\r\n      });\r\n      cNode = pathNodes[smallestDistIndex];\r\n\r\n      this.buildCurrentStep(pathNodes, unvisited, cNode);\r\n      // if the smallest distance is infinity still, there is no path, so end.\r\n      if (cNode.distance === Infinity) {\r\n        return [];\r\n      }\r\n    }\r\n    return [];\r\n  };\r\n\r\n  buildCurrentStep(\r\n    pathNodes: pathNode[],\r\n    unvisited: number[],\r\n    nextNode: pathNode\r\n  ) {\r\n    let stepNodes: GRID_ITEM_STATUS[] = pathNodes.map((node, index) => {\r\n      if (node.weight === 0) {\r\n        return GRID_ITEM_STATUS.WALL;\r\n      } else if (node.prevNode !== undefined && unvisited.includes(index)) {\r\n        return GRID_ITEM_STATUS.EXPLORING;\r\n      } else if (node.prevNode !== undefined) {\r\n        return GRID_ITEM_STATUS.EXPLORED;\r\n      }\r\n      return GRID_ITEM_STATUS.OPEN;\r\n    });\r\n\r\n    this.pathStepArray.push(stepNodes);\r\n  }\r\n}\r\n","export interface HeapData {\r\n  key: number;\r\n  value: number;\r\n}\r\n\r\n/**\r\n * Binary min kvheap\r\n * @param key keys are used to sort the array.\r\n * @param value values are stored with the key.\r\n */\r\nexport class BinaryMinHeapKV {\r\n  heap: HeapData[];\r\n  constructor() {\r\n    this.heap = [];\r\n  }\r\n\r\n  /**\r\n   * Gets parent index\r\n   * @param index\r\n   * @returns {number} parent index\r\n   */\r\n  private getParent = (index: number) => {\r\n    return Math.floor((index - 1) / 2);\r\n  };\r\n\r\n  /**\r\n   * Get index of left child of parent\r\n   * @param parent parent index\r\n   * @returns {number} left child index\r\n   */\r\n  private getLeft = (parent: number) => {\r\n    return parent * 2 + 1;\r\n  };\r\n\r\n  /**\r\n   * Get index for right child of parent\r\n   * @param parent parent index\r\n   * @returns {number} right child index\r\n   */\r\n  private getRight = (parent: number) => {\r\n    return parent * 2 + 2;\r\n  };\r\n\r\n  /**\r\n   * Swaps index1 and index2 in the heap.\r\n   * @param index1 index of heap to swap\r\n   * @param index2 index of heap to swap\r\n   */\r\n  private swap = (index1: number, index2: number) => {\r\n    let t = this.heap[index1];\r\n    this.heap[index1] = this.heap[index2];\r\n    this.heap[index2] = t;\r\n  };\r\n\r\n  /**\r\n   * Determines whether key of indexA is less than key of indexB\r\n   * @param indexA index of heap\r\n   * @param indexB index of heap to compare to\r\n   * @returns {boolean} true if A.key < B.key otherwise false.\r\n   */\r\n  private isKeyALessThanB = (indexA: number, indexB: number) => {\r\n    if (this.heap[indexA].key < this.heap[indexB].key) {\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Recursively sifts down HeapData at index until min heap is preserved\r\n   * @param index index of heap to sift down\r\n   */\r\n  private siftDown = (index: number) => {\r\n    let { heap, getLeft, getRight, isKeyALessThanB, siftDown, swap } = this;\r\n    if (index >= 0) {\r\n      let left = getLeft(index);\r\n      let right = getRight(index);\r\n      // have to check if they are undefined before comparisons.\r\n      if (heap[left] && heap[right]) {\r\n        // need to make sure at least one of them is lower before we swap...\r\n        if (isKeyALessThanB(left, index) || isKeyALessThanB(right, index)) {\r\n          // will swap right with index if left === right.\r\n          let lowerIndex = isKeyALessThanB(left, right) ? left : right;\r\n          swap(lowerIndex, index);\r\n          siftDown(lowerIndex);\r\n        }\r\n      } else if (heap[left] && isKeyALessThanB(left, index)) {\r\n        swap(left, index);\r\n        siftDown(left);\r\n      } else if (heap[right] && isKeyALessThanB(right, index)) {\r\n        swap(right, index);\r\n        siftDown(right);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Inserts key, value into binary min heap.\r\n   * @param key number used to sort binary minheap\r\n   * @param value number also stored with key.\r\n   */\r\n  public insert = (key: number, value: number) => {\r\n    let heapData: HeapData = { key: key, value: value };\r\n    this.heap.push(heapData);\r\n\r\n    let swapRecursive = (index: number) => {\r\n      let parent = this.getParent(index);\r\n      if (parent >= 0 && this.heap[parent].key > this.heap[index].key) {\r\n        this.swap(index, parent);\r\n        swapRecursive(parent);\r\n      }\r\n    };\r\n    swapRecursive(this.heap.length - 1);\r\n  };\r\n\r\n  /**\r\n   * Removes and returns the minimum value of the heap\r\n   * @returns {HeapData} {key: number, value: number} of minimum of heap.\r\n   */\r\n  public extractMin = () => {\r\n    let { heap, siftDown } = this;\r\n    let min = {\r\n      key: heap[0].key,\r\n      value: heap[0].value\r\n    };\r\n    // replace first element with last element.\r\n    heap[0] = heap[heap.length - 1];\r\n    // remove last element from heap.\r\n    heap.pop();\r\n    // sift down the first element.\r\n    siftDown(0);\r\n    return min;\r\n  };\r\n\r\n  /**\r\n   * Determines if the minheap is empty\r\n   * @returns {boolean} true or false\r\n   */\r\n  public isEmpty = () => {\r\n    if (this.heap.length > 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Determines whether value is in the heap\r\n   * @param value Value stored with key\r\n   * @returns {boolean} true or false\r\n   */\r\n  public containsValue = (value: number) => {\r\n    return this.heap.some(item => item.value === value);\r\n  };\r\n}\r\n","import { PathAlgorithm, pathNode, pathData } from \"./PathAlgorithm\";\r\nimport { BinaryMinHeapKV } from \"./BinaryMinHeapKV\";\r\nimport { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport class AStarAlgorithm extends PathAlgorithm {\r\n  endX: number;\r\n  endY: number;\r\n\r\n  constructor(data: pathData) {\r\n    super(data);\r\n\r\n    let { endX, endY } = this.getEndXY();\r\n    this.endX = endX;\r\n    this.endY = endY;\r\n  }\r\n\r\n  /**\r\n   * Calculates path using the A* algorithm.\r\n   * @param greedy Should path calculation use the greedy algorithm\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath(greedy: boolean = false) {\r\n    let { start, end, nodes } = this;\r\n    let pathNodes: pathNode[] = this.createNodeArray(nodes);\r\n\r\n    // nodes that have been explored\r\n    let closedNodes = new Set<number>();\r\n\r\n    // the cost of the cheapest path from start to n currently known\r\n    let gScore: number[] = new Array(pathNodes.length).fill(Infinity);\r\n    gScore[start] = 0;\r\n\r\n    // fScore[n] = gScores[n] + heuristic(n)\r\n    let fScore = [...gScore];\r\n    fScore[start] = this.getHeuristic(start);\r\n\r\n    // min heap of nodes that can still be explored\r\n    let minHeap = new BinaryMinHeapKV();\r\n    minHeap.insert(this.getHeuristic(start), start);\r\n\r\n    while (!minHeap.isEmpty()) {\r\n      // get lowest fscore node in minheap.\r\n      let currentNodeIndex = minHeap.extractMin().value;\r\n      let currentNode = pathNodes[currentNodeIndex];\r\n      if (currentNode.i === end) {\r\n        this.pathNodeArray = pathNodes;\r\n        return this.buildPathArray(pathNodes);\r\n      }\r\n\r\n      closedNodes.add(currentNodeIndex);\r\n      let neighbours = this.getNodeNeighbours(currentNode.i);\r\n      neighbours.forEach(neighbourIndex => {\r\n        if (closedNodes.has(neighbourIndex)) {\r\n          return;\r\n        }\r\n        // if it's not a wall.\r\n        if (pathNodes[neighbourIndex].weight !== 0) {\r\n          // Calculate a new gScore.\r\n          let newGScore =\r\n            gScore[currentNodeIndex] + pathNodes[neighbourIndex].weight;\r\n          if (newGScore < gScore[neighbourIndex]) {\r\n            // Update gscore, fScore, prevNode, and add to the openNodes array.\r\n            pathNodes[neighbourIndex].prevNode = currentNodeIndex;\r\n            gScore[neighbourIndex] = newGScore;\r\n\r\n            if (!greedy) {\r\n              // non-greedy cares about the weight to the node as well.\r\n              fScore[neighbourIndex] =\r\n                newGScore + this.getHeuristic(neighbourIndex);\r\n            } else {\r\n              // greedy only cares about the heuristic, and its weight\r\n              fScore[neighbourIndex] = this.getHeuristic(neighbourIndex);\r\n            }\r\n\r\n            // Don't need to check if minheap already contains the neighbour\r\n            // can just re-insert it instead of updating key / re-heapifying\r\n            // as it will be added to closedNodes if it's the lowest, and never added again.\r\n\r\n            minHeap.insert(fScore[neighbourIndex], neighbourIndex);\r\n            this.buildCurrentStep(closedNodes, pathNodes);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Get end's x,y position for use in algorithm.\r\n   * @returns object with endX and endY properties\r\n   */\r\n  getEndXY = () => {\r\n    let endY = Math.floor(this.end / this.columns);\r\n    let endX = this.end - endY * this.columns;\r\n    return { endX, endY };\r\n  };\r\n\r\n  /**\r\n   * Calculates the heuristic for the current index in a* algorithm by manhattan distance\r\n   * @returns Manhattan distance from index to end position.\r\n   */\r\n  getHeuristic = (index: number) => {\r\n    let y = Math.floor(index / this.columns);\r\n    let x = index - y * this.columns;\r\n    return Math.abs(this.endY - y) + Math.abs(this.endX - x);\r\n  };\r\n\r\n  buildCurrentStep(closedNodes: Set<number>, pathNodes: pathNode[]) {\r\n    let stepNodes: GRID_ITEM_STATUS[] = pathNodes.map((node, index) => {\r\n      if (node.weight === 0) {\r\n        return GRID_ITEM_STATUS.WALL;\r\n      }\r\n      if (node.prevNode !== undefined && closedNodes.has(index)) {\r\n        return GRID_ITEM_STATUS.EXPLORED;\r\n      } else if (node.prevNode !== undefined) {\r\n        return GRID_ITEM_STATUS.EXPLORING;\r\n      }\r\n      return GRID_ITEM_STATUS.OPEN;\r\n    });\r\n    this.pathStepArray.push(stepNodes);\r\n  }\r\n}\r\n","import { PATH_ALGORITHM } from \"../Constants/enums\";\r\nimport { DijkstraAlgorithm } from \"./DijkstraAlgorithm\";\r\nimport { AStarAlgorithm } from \"./AStarAlgorithm\";\r\nimport { PathAlgorithm } from \"./PathAlgorithm\";\r\n\r\nexport class Pathfinder {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n  pathAlgorithm: PathAlgorithm;\r\n  constructor(\r\n    nodes: number[],\r\n    rows: number,\r\n    columns: number,\r\n    start: number,\r\n    end: number\r\n  ) {\r\n    this.nodes = nodes;\r\n    this.rows = rows;\r\n    this.columns = columns;\r\n    this.start = start;\r\n    this.end = end;\r\n    this.path = [];\r\n    this.pathAlgorithm = new PathAlgorithm(this.getDataObject());\r\n  }\r\n\r\n  private getDataObject = () => {\r\n    return {\r\n      nodes: this.nodes,\r\n      rows: this.rows,\r\n      columns: this.columns,\r\n      start: this.start,\r\n      end: this.end,\r\n      path: []\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Calculates and returns the path for the specified algorithm\r\n   * @param [algorithm] Type of algorithm to use\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath(algorithm?: PATH_ALGORITHM) {\r\n    let data = this.getDataObject();\r\n    let alg;\r\n    switch (algorithm) {\r\n      case PATH_ALGORITHM.ASTAR_GREEDY:\r\n        alg = new AStarAlgorithm(data);\r\n        this.path = alg.calcPath(true);\r\n        break;\r\n      case PATH_ALGORITHM.ASTAR:\r\n        alg = new AStarAlgorithm(data);\r\n        this.path = alg.calcPath();\r\n        break;\r\n      default:\r\n        alg = new DijkstraAlgorithm(data);\r\n        this.path = alg.calcPath();\r\n        break;\r\n    }\r\n    this.pathAlgorithm = alg;\r\n    return this.path;\r\n  }\r\n\r\n  getPathNodes() {\r\n    return this.pathAlgorithm.pathNodeArray;\r\n  }\r\n\r\n  getPathSteps() {\r\n    return this.pathAlgorithm.pathStepArray;\r\n  }\r\n\r\n  getPathStepsLength() {\r\n    return this.pathAlgorithm.pathStepArray.length;\r\n  }\r\n\r\n  getNextPathStep() {\r\n    return this.pathAlgorithm.getNextPathStep();\r\n  }\r\n}\r\n","import React, { ChangeEvent } from \"react\";\r\n\r\nimport GridItem from \"../../Components/GridItem/GridItem\";\r\nimport { GRID_ITEM_STATUS, PATH_ALGORITHM } from \"../../Constants/enums\";\r\n\r\nimport \"./Grid.css\";\r\nimport { Pathfinder } from \"../../Classes/Pathfinder\";\r\nimport { pathNode } from \"../../Classes/PathAlgorithm\";\r\n\r\ntype GridProps = {\r\n  rows: number;\r\n  columns: number;\r\n};\r\n\r\n/**\r\n * @param nodes Nodes of the grid, 0 is not-walkable (ie a wall), all other values are the weight of going to that node.\r\n */\r\ntype GridState = {\r\n  nodes: number[];\r\n  path: number[];\r\n  algorithm: PATH_ALGORITHM;\r\n  isDragging: boolean;\r\n  isCreatingWalls: boolean;\r\n  dragStartIndex: number;\r\n  dragStartInitialWeight: number;\r\n  dragEndIndex: number;\r\n  pathNodes: pathNode[];\r\n  pathStep: GRID_ITEM_STATUS[];\r\n  waitTime: number;\r\n};\r\n\r\nclass Grid extends React.Component<GridProps, GridState> {\r\n  constructor(props: GridProps) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      /** Nodes of the grid, 0 is not-walkable (ie a wall), all other values are the weight of going to that node. */\r\n      nodes: new Array(props.rows * props.columns).fill(1),\r\n      path: [],\r\n      algorithm: PATH_ALGORITHM.DIJKSTRA,\r\n      isDragging: false,\r\n      isCreatingWalls: false,\r\n      dragStartInitialWeight: 0,\r\n      dragStartIndex: 0,\r\n      dragEndIndex: 0,\r\n      pathNodes: [],\r\n      pathStep: new Array(props.rows * props.columns).fill(\r\n        GRID_ITEM_STATUS.OPEN\r\n      ),\r\n      waitTime: 5\r\n    };\r\n    this.state.pathStep[0] = GRID_ITEM_STATUS.START;\r\n    this.state.pathStep[this.state.pathStep.length - 1] = GRID_ITEM_STATUS.END;\r\n    this.state.nodes[0] = -1;\r\n    this.state.nodes[this.state.nodes.length - 1] = -2;\r\n  }\r\n\r\n  componentDidUpdate(prevProps: GridProps) {\r\n    if (\r\n      this.props.columns !== prevProps.columns ||\r\n      this.props.rows !== prevProps.rows\r\n    ) {\r\n      this.resetPathState(true);\r\n    }\r\n  }\r\n\r\n  resetPathState = (resetNodes = false) => {\r\n    let nodes = new Array(this.props.rows * this.props.columns).fill(1);\r\n    nodes[0] = -1;\r\n    nodes[nodes.length - 1] = -2;\r\n    this.setState({\r\n      nodes: resetNodes ? nodes : this.state.nodes,\r\n      path: [],\r\n      pathNodes: [],\r\n      pathStep: []\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Generates grid items\r\n   * @param rows Number of rows to create\r\n   * @param columns Number of columns to create\r\n   * @returns array of grid__item 's\r\n   */\r\n  generateGridItems = (\r\n    rows: number,\r\n    columns: number,\r\n    nodes = this.state.nodes\r\n  ) => {\r\n    let gridItems = [];\r\n    for (let y = 0; y < rows; y++) {\r\n      for (let x = 0; x < columns; x++) {\r\n        let i = y * columns + x;\r\n        let status = this.state.pathStep[i];\r\n        if (this.state.path.includes(i)) {\r\n          status = GRID_ITEM_STATUS.PATH;\r\n        }\r\n        if (nodes[i] === 0) {\r\n          status = GRID_ITEM_STATUS.WALL;\r\n        }\r\n        if (nodes[i] === -1) {\r\n          status = GRID_ITEM_STATUS.START;\r\n        }\r\n        if (nodes[i] === -2) {\r\n          status = GRID_ITEM_STATUS.END;\r\n        }\r\n        gridItems.push(\r\n          <div className=\"item__container--square\" key={\"ics\" + x + \"_\" + y}>\r\n            <GridItem\r\n              status={status}\r\n              key={\"gi_\" + x + \"_\" + y}\r\n              row={y}\r\n              column={x}\r\n              weight={nodes[y * columns + x] ? nodes[y * columns + x] : 0}\r\n              index={y * columns + x}\r\n              displayWeight={columns > 7 && rows > 7 ? false : true}\r\n              onChange={this.onChangeNodeWeight}\r\n              onMouseEnterGridItem={this.onMouseEnterGridItem}\r\n              onMouseDownGridItem={this.onMouseDownGridItem}\r\n              onMouseUpGridItem={this.onMouseUpGridItem}\r\n              onTouchMove={this.onTouchMoveGridItem}\r\n              onTouchEnd={this.onTouchEndGridItem}\r\n            />\r\n          </div>\r\n        );\r\n      }\r\n    }\r\n    return gridItems;\r\n  };\r\n\r\n  /**\r\n   * Changes node at index to e.target.value\r\n   * @param index index of element in nodes array\r\n   */\r\n  onChangeNodeWeight = (index: number) => (\r\n    e: React.ChangeEvent<HTMLInputElement>\r\n  ) => {\r\n    let newNodes = [...this.state.nodes];\r\n    newNodes[index] = parseInt(e.target.value);\r\n    this.setState({ nodes: newNodes });\r\n  };\r\n\r\n  /**\r\n   * Set waitTime state of grid\r\n   * @param val Value to set waitTime to\r\n   */\r\n  setWaitTime = (val: number) => {\r\n    this.setState(state => {\r\n      return { waitTime: val };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Gets grid styles\r\n   * @param rows number of rows\r\n   * @param columns number of columns\r\n   * @returns  React.CSSProperties { width, height, gridTemplateColumns, gridTemplateRows }\r\n   */\r\n  getGridStyles = (rows: number, columns: number) => {\r\n    let style = this.getGridTemplate(columns);\r\n    Object.assign(style, this.calcGridHeightAndWidth(rows, columns));\r\n    return style;\r\n  };\r\n\r\n  /**\r\n   * Calcs grid height and width\r\n   * @param rows numbers of rows\r\n   * @param columns number of columns\r\n   * @returns React.CSSProperties { width: value, height: value } as % of it's container to keep each grid item a square.\r\n   */\r\n  calcGridHeightAndWidth = (rows: number, columns: number) => {\r\n    let width = 100;\r\n    let height = 100;\r\n    if (rows > columns) {\r\n      width = (columns / rows) * 100;\r\n    } else {\r\n      height = (rows / columns) * 100;\r\n    }\r\n    let gridWidth: React.CSSProperties = {\r\n      width: width + \"%\",\r\n      height: height + \"%\"\r\n    };\r\n    return gridWidth;\r\n  };\r\n\r\n  /**\r\n   * Gets grid template\r\n   * @param columns number of columns\r\n   * @returns React.CSSProperties { gridTemplateColumns: value, gridTemplateRows: value }\r\n   */\r\n  getGridTemplate = (columns: number) => {\r\n    let templateColumns = \"\";\r\n    for (let i = 0; i < columns; i++) {\r\n      templateColumns += \"1fr \";\r\n    }\r\n    let gridTemplate: React.CSSProperties = {\r\n      gridTemplateColumns: templateColumns\r\n    };\r\n    return gridTemplate;\r\n  };\r\n\r\n  /**\r\n   * Uses pathfinder.js and the state of the grid to\r\n   * calculate a path and display it.\r\n   */\r\n  onCalculatePath = () => {\r\n    this.resetPathState();\r\n    let pathfinder = new Pathfinder(\r\n      this.state.nodes,\r\n      this.props.rows,\r\n      this.props.columns,\r\n      this.state.nodes.indexOf(-1),\r\n      this.state.nodes.indexOf(-2)\r\n    );\r\n    let path = pathfinder.calcPath(this.state.algorithm);\r\n    let pathNodes = pathfinder.getPathNodes();\r\n    this.setState({ path: path, pathNodes: pathNodes });\r\n  };\r\n\r\n  onCalculatePathSteps = () => {\r\n    this.resetPathState();\r\n    let pathfinder = new Pathfinder(\r\n      this.state.nodes,\r\n      this.props.rows,\r\n      this.props.columns,\r\n      this.state.nodes.indexOf(-1),\r\n      this.state.nodes.indexOf(-2)\r\n    );\r\n    pathfinder.calcPath(this.state.algorithm);\r\n    this.DisplayPathSteps(pathfinder);\r\n  };\r\n\r\n  async DisplayPathSteps(pathfinder: Pathfinder) {\r\n    let steps = pathfinder.getPathStepsLength();\r\n    let path = pathfinder.path;\r\n    for (let i = 0; i < steps; i++) {\r\n      this.setState({ pathStep: pathfinder.getNextPathStep() });\r\n      await this.wait(this.state.waitTime);\r\n    }\r\n    this.setState({ path: path });\r\n  }\r\n\r\n  wait = (ms: number) => new Promise(res => setTimeout(res, ms));\r\n\r\n  /**\r\n   * Changes the algorithm state based on select elements value.\r\n   */\r\n  onChangeAlgorithm = (e: ChangeEvent<HTMLSelectElement>) => {\r\n    this.setState({ algorithm: parseInt(e.target.value) });\r\n  };\r\n\r\n  /**\r\n   * Sets is dragging to false, and the dragEndIndex to index.\r\n   * Changes the node at index to a wall or open if that nodes weight wasn't\r\n   * changed between MouseDown & MouseUp.\r\n   * @param index index of node array that mouseup event was called on.\r\n   */\r\n  stopDragAt = (index: number) => {\r\n    // it was a mouse click\r\n    if (\r\n      this.state.dragStartIndex === index &&\r\n      this.state.dragStartInitialWeight === this.state.nodes[index]\r\n    ) {\r\n      let nodes = [...this.state.nodes];\r\n      let tempVal = nodes[index] - 1;\r\n      // make sure we dont go below start/end markers\r\n      if (tempVal < -2) {\r\n        //set end node to last node\r\n        tempVal = 1;\r\n        nodes[nodes.length - 1] = -2;\r\n      } else if (tempVal === -2) {\r\n        // is making an end node, need a new start node, set to first node, clear current end node.\r\n        nodes[nodes.indexOf(-2)] = 1;\r\n        nodes[0] = -1;\r\n      } else if (tempVal === -1) {\r\n        // new start node, clear previous start node.\r\n        nodes[nodes.indexOf(-1)] = 1;\r\n      }\r\n      nodes[index] = tempVal;\r\n\r\n      this.setState(state => {\r\n        return {\r\n          isDragging: false,\r\n          dragEndIndex: index,\r\n          nodes: nodes\r\n        };\r\n      });\r\n    } else {\r\n      // it was actually a drag.\r\n      this.setState(state => {\r\n        return { isDragging: false, dragEndIndex: index };\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sets isdragging state to false\r\n   * Used for when mouse exits grid area on drag,\r\n   * or if touch event ends.\r\n   */\r\n  stopDrag = () => {\r\n    // Would need an index to call stopDragAt, which would need a\r\n    // last updated index state.\r\n    this.setState(state => {\r\n      return { isDragging: false };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Updates state of isDragging to true, dragStartIndex to index,\r\n   * dragStartInitialWeight to node at index's weight,\r\n   * sets isCreatingWalls state based on node at index's weight\r\n   * @param index index in node array that mousedown was called on.\r\n   */\r\n  startDragAt = (index: number) => {\r\n    this.resetPathState();\r\n    this.setState(state => {\r\n      return {\r\n        isDragging: true,\r\n        dragStartIndex: index,\r\n        dragStartInitialWeight: this.state.nodes[index],\r\n        isCreatingWalls: this.state.nodes[index] === 0 ? false : true\r\n      };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * If user is dragging, changes node weight to 0 or 1\r\n   * depending on if they started dragging on a wall or open node,\r\n   * and updates the node state.\r\n   * @param index index in node array that mouse entered\r\n   */\r\n  continueDragAt = (index: number) => {\r\n    if (this.state.isDragging) {\r\n      if (index !== this.state.dragStartIndex) {\r\n        // User is dragging, so switch between walls & open tiles.\r\n        let nodes = [...this.state.nodes];\r\n        nodes[index] = this.state.isCreatingWalls ? 0 : 1;\r\n        nodes[this.state.dragStartIndex] = nodes[index];\r\n        this.setState(state => {\r\n          return { nodes: nodes };\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Update drag state variables on mouse down.\r\n   * @param index index in node array that mousedown was called on.\r\n   */\r\n  onMouseDownGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.startDragAt(index);\r\n    if (e.target === e.currentTarget) {\r\n      e.preventDefault();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Update drag state on mouse up.\r\n   * @param index index of node array that mouseup event was called on.\r\n   */\r\n  onMouseUpGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.stopDragAt(index);\r\n  };\r\n\r\n  /**\r\n   * Upgrade node state on mouse enter\r\n   * @param index index in node array that mouse entered\r\n   */\r\n  onMouseEnterGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.continueDragAt(index);\r\n  };\r\n\r\n  /**\r\n   * Sets state of dragging to false\r\n   */\r\n  onMouseExitGrid = (e: React.MouseEvent) => {\r\n    this.stopDrag();\r\n  };\r\n\r\n  /**\r\n   * Updates state for nodes & dragging based on element touch is over.\r\n   */\r\n  onTouchMoveGridItem = (e: React.TouchEvent) => {\r\n    let el = document.elementFromPoint(\r\n      e.touches[0].clientX,\r\n      e.touches[0].clientY\r\n    );\r\n    // need to make sure we have a valid element & valid data.\r\n    if (el !== null) {\r\n      let data = el.getAttribute(\"data-index\");\r\n      if (data !== null) {\r\n        let index = parseInt(data);\r\n        if (this.state.isDragging === false) {\r\n          this.startDragAt(index);\r\n        } else {\r\n          this.continueDragAt(index);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sets is dragging state to false.\r\n   */\r\n  onTouchEndGridItem = (e: React.TouchEvent) => {\r\n    this.stopDrag();\r\n  };\r\n\r\n  render() {\r\n    const { rows, columns } = this.props;\r\n    const { nodes, waitTime } = this.state;\r\n    return (\r\n      <>\r\n        <div\r\n          className=\"grid__container\"\r\n          style={this.getGridStyles(rows, columns)}\r\n          onMouseLeave={this.onMouseExitGrid}\r\n        >\r\n          {this.generateGridItems(rows, columns, nodes)}\r\n        </div>\r\n        <div className=\"grid__flexContainer\">\r\n          <div className=\"flex__innerContainer\">\r\n            <button\r\n              id=\"calc_path\"\r\n              className=\"flex__button\"\r\n              onClick={this.onCalculatePath}\r\n            >\r\n              Calculate Path\r\n            </button>\r\n            <button\r\n              id=\"calc_path_steps\"\r\n              className=\"flex__button\"\r\n              onClick={this.onCalculatePathSteps}\r\n            >\r\n              Show Path Steps\r\n            </button>\r\n          </div>\r\n          <div className=\"flex__innerContainer\">\r\n            <div className=\"input__container\">\r\n              <label htmlFor=\"select_algorithm\">Algorithm:</label>\r\n              <select\r\n                id=\"select_algorithm\"\r\n                className=\"input__item\"\r\n                onChange={this.onChangeAlgorithm}\r\n              >\r\n                <option value={PATH_ALGORITHM.DIJKSTRA}>Dijkstra</option>\r\n                <option value={PATH_ALGORITHM.ASTAR}>A*</option>\r\n                <option value={PATH_ALGORITHM.ASTAR_GREEDY}>A* Greedy</option>\r\n              </select>\r\n            </div>\r\n            <div className=\"input__container\">\r\n              <label htmlFor=\"waitTime\">Step Delay Time:</label>\r\n              <input\r\n                id=\"waitTime\"\r\n                className=\"input__item\"\r\n                type=\"number\"\r\n                min={3}\r\n                value={waitTime}\r\n                onChange={e => this.setWaitTime(parseInt(e.target.value))}\r\n              />\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Grid;\r\n","import React, { useState } from \"react\";\r\n\r\nimport Grid from \"./Containers/Grid/Grid\";\r\n\r\nimport \"./App.css\";\r\n\r\nconst App: React.FC = () => {\r\n  const [rows, setRows] = useState(8);\r\n  const [columns, setColumns] = useState(8);\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"app__container\">\r\n        <div className=\"app__inputContainer\">\r\n          <div className=\"input__container\">\r\n            <label htmlFor=\"rows\">Rows:</label>\r\n            <input\r\n              id=\"rows\"\r\n              className=\"input__item\"\r\n              type=\"number\"\r\n              min={3}\r\n              value={rows}\r\n              onChange={e => setRows(parseInt(e.target.value))}\r\n            />\r\n          </div>\r\n          <div className=\"input__container\">\r\n            <label htmlFor=\"columns\">Columns:</label>\r\n            <input\r\n              id=\"rows\"\r\n              className=\"input__item\"\r\n              type=\"number\"\r\n              min={3}\r\n              value={columns}\r\n              onChange={e => setColumns(parseInt(e.target.value))}\r\n            />\r\n          </div>\r\n        </div>\r\n        <Grid rows={rows} columns={columns} />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}