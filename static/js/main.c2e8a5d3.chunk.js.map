{"version":3,"sources":["Constants/enums.ts","Components/GridItem/GridItem.tsx","Classes/PathAlgorithm.ts","Classes/DijkstraAlgorithm.ts","Classes/BinaryMinHeapKV.ts","Classes/AStarAlgorithm.ts","Classes/DualAStarAlgorithm.ts","Classes/Pathfinder.ts","Containers/Grid/Grid.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["GRID_ITEM_STATUS","PATH_ALGORITHM","GridItem","row","column","weight","index","status","displayWeight","onChange","onMouseEnterGridItem","onMouseDownGridItem","onMouseUpGridItem","onTouchMove","onTouchEnd","className","START","END","EXPLORED","EXPLORING","PATH","WALL","getClassNameFromStatus","onMouseEnter","onMouseDown","onMouseUp","data-index","htmlFor","id","type","value","min","PathAlgorithm","data","nodes","start","end","rows","columns","path","pathNodeArray","pathStepArray","pathStepCurrent","this","map","i","distance","prevNode","undefined","neighbours","y","Math","floor","x","push","pathNodes","pathNode","reverse","DijkstraAlgorithm","calcPath","createNodeArray","unvisited","forEach","item","Infinity","cNode","getNodeNeighbours","cDistance","cIndex","includes","splice","indexOf","buildPathArray","smallestDistIndex","buildCurrentStep","length","nextNode","stepNodes","node","OPEN","BinaryMinHeapKV","heap","getParent","getLeft","parent","getRight","swap","index1","index2","t","isKeyALessThanB","indexA","indexB","key","siftDown","left","right","lowerIndex","insert","heapData","swapRecursive","extractMin","pop","isEmpty","containsValue","some","AStarAlgorithm","endX","endY","getEndXY","getHeuristic","abs","greedy","closedNodes","Set","gScore","Array","fill","fScore","minHeap","currentNodeIndex","currentNode","add","neighbourIndex","has","newGScore","DualAStarAlgorithm","startX","startY","getXYForIndex","toStart","doNeighbourCalculations","endXY","startXY","pathStartNodes","pathEndNodes","closedStart","closedEnd","gEnd","fEnd","minheapEnd","minheapStart","startNodeIndex","endNodeIndex","startNode","prev","cur","neighboursStart","nieghboursEnd","pathEnd","Pathfinder","pathAlgorithm","getDataObject","algorithm","alg","ASTAR_GREEDY","ASTAR","ASTAR_DUAL","getNextPathStep","Grid","props","resetPathState","resetNodes","setState","state","pathStep","generateGridItems","gridItems","onChangeNodeWeight","onTouchMoveGridItem","onTouchEndGridItem","e","newNodes","parseInt","target","setWaitTime","val","waitTime","getGridStyles","style","getGridTemplate","Object","assign","calcGridHeightAndWidth","width","height","templateColumns","gridTemplateColumns","onCalculatePath","pathfinder","getPathNodes","onCalculatePathSteps","DisplayPathSteps","wait","ms","Promise","res","setTimeout","onChangeAlgorithm","stopDragAt","dragStartIndex","dragStartInitialWeight","tempVal","isDragging","dragEndIndex","stopDrag","startDragAt","isCreatingWalls","continueDragAt","currentTarget","preventDefault","onMouseExitGrid","el","document","elementFromPoint","touches","clientX","clientY","getAttribute","DIJKSTRA","prevProps","steps","getPathStepsLength","onMouseLeave","onClick","React","Component","App","useState","setRows","setColumns","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c2e8a5d3.chunk.js","sourcesContent":["export enum GRID_ITEM_STATUS {\r\n  OPEN = 1,\r\n  WALL,\r\n  START,\r\n  END,\r\n  PATH,\r\n  EXPLORED,\r\n  EXPLORING\r\n}\r\n\r\nexport enum PATH_ALGORITHM {\r\n  DIJKSTRA = 1,\r\n  ASTAR,\r\n  ASTAR_GREEDY,\r\n  ASTAR_DUAL\r\n}\r\n","import React from \"react\";\r\n\r\nimport \"./GridItem.css\";\r\nimport { GRID_ITEM_STATUS } from \"../../Constants/enums\";\r\n\r\ntype GridItemProps = {\r\n  row: number;\r\n  column: number;\r\n  weight: number;\r\n  index: number;\r\n  status: GRID_ITEM_STATUS;\r\n  displayWeight: boolean;\r\n  onChange: (index: number) => React.ChangeEventHandler<HTMLInputElement>;\r\n  onMouseEnterGridItem: (index: number) => React.MouseEventHandler;\r\n  onMouseDownGridItem: (index: number) => React.MouseEventHandler;\r\n  onMouseUpGridItem: (index: number) => React.MouseEventHandler;\r\n  onTouchMove: React.TouchEventHandler;\r\n  onTouchEnd: React.TouchEventHandler;\r\n};\r\n\r\nconst GridItem = ({\r\n  row,\r\n  column,\r\n  weight,\r\n  index,\r\n  status,\r\n  displayWeight,\r\n  onChange,\r\n  onMouseEnterGridItem,\r\n  onMouseDownGridItem,\r\n  onMouseUpGridItem,\r\n  onTouchMove,\r\n  onTouchEnd\r\n}: GridItemProps) => {\r\n  const getClassNameFromStatus = (status: GRID_ITEM_STATUS, weight: number) => {\r\n    let className = \"grid__item\";\r\n    switch (status) {\r\n      case GRID_ITEM_STATUS.START:\r\n        return (className += \" grid__item--start\");\r\n      case GRID_ITEM_STATUS.END:\r\n        return (className += \" grid__item--end\");\r\n      case GRID_ITEM_STATUS.EXPLORED:\r\n        return (className += \" grid__item--explored\");\r\n      case GRID_ITEM_STATUS.EXPLORING:\r\n        return (className += \" grid__item--exploring\");\r\n      case GRID_ITEM_STATUS.PATH:\r\n        return (className += \" grid__item--path\");\r\n      case GRID_ITEM_STATUS.WALL:\r\n        return (className += \" grid__item--wall\");\r\n      default:\r\n        return className;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={getClassNameFromStatus(status, weight)}\r\n      onMouseEnter={onMouseEnterGridItem(index)}\r\n      onMouseDown={onMouseDownGridItem(index)}\r\n      onMouseUp={onMouseUpGridItem(index)}\r\n      onTouchMove={onTouchMove}\r\n      onTouchEnd={onTouchEnd}\r\n      data-index={index}\r\n    >\r\n      <p className=\"item__index\">i:{index}</p>\r\n      {displayWeight && (\r\n        <div className=\"item__data\">\r\n          <label htmlFor=\"weight-input\">W:</label>\r\n          <input\r\n            id=\"weight-input\"\r\n            className=\"item__input\"\r\n            type=\"number\"\r\n            value={weight}\r\n            onChange={onChange(index)}\r\n            min={0}\r\n          />\r\n        </div>\r\n      )}\r\n      <p className=\"item__coords\">({column + \",\" + row})</p>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GridItem;\r\n","import { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport type pathNode = {\r\n  i: number;\r\n  distance: number;\r\n  weight: number;\r\n  prevNode?: number;\r\n};\r\n\r\nexport type pathData = {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n};\r\n\r\nexport class PathAlgorithm {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n  pathNodeArray: pathNode[];\r\n  pathStepArray: [GRID_ITEM_STATUS[]];\r\n  pathStepCurrent: number;\r\n  constructor(data: pathData) {\r\n    this.nodes = data.nodes;\r\n    this.rows = data.rows;\r\n    this.columns = data.columns;\r\n    this.start = data.start;\r\n    this.end = data.end;\r\n    this.path = [];\r\n    this.pathNodeArray = [];\r\n    this.pathStepArray = [[]];\r\n    this.pathStepCurrent = 0;\r\n  }\r\n\r\n  /**\r\n   * Creates the array of pathNode's\r\n   * @param nodes array of nodes with weights\r\n   * @returns array of pathNode's\r\n   */\r\n  createNodeArray(nodes: number[]) {\r\n    let nodeArray: pathNode[] = nodes.map((value, i) => {\r\n      return { i, distance: 0, weight: value, prevNode: undefined };\r\n    });\r\n    //  console.log(\"INITIAL\");\r\n    //  console.log(nodeArray[5].prevNode);\r\n    // console.log(\"--INITIAL--\");\r\n    return nodeArray;\r\n  }\r\n\r\n  /**\r\n   * Gets the indexes of the nodes neighbours.\r\n   * @param index index of node to get neighbours for.\r\n   * @returns array of neighbours by index\r\n   */\r\n  getNodeNeighbours(index: number) {\r\n    let { rows, columns } = this;\r\n    let neighbours = [];\r\n    // x & y values:\r\n    let y = Math.floor(index / columns);\r\n    let x = index - y * columns;\r\n    // right & left neighbors\r\n    if (x - 1 >= 0) {\r\n      neighbours.push(index - 1);\r\n    }\r\n    if (x + 1 < columns) {\r\n      neighbours.push(index + 1);\r\n    }\r\n    // up / down neighbors\r\n    if (y - 1 >= 0) {\r\n      neighbours.push(index - columns);\r\n    }\r\n    if (y + 1 < rows) {\r\n      neighbours.push(index + columns);\r\n    }\r\n    return neighbours;\r\n  }\r\n\r\n  /**\r\n   * Builds the array of the path taken to reach the end node.\r\n   * @param pathNodes array containing the calculated path data\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  buildPathArray(pathNodes: pathNode[]) {\r\n    let path = [];\r\n    let pathNode = pathNodes[this.end];\r\n    while (pathNode.prevNode !== undefined) {\r\n      // console.log(\"-\");\r\n      //console.log(pathNode.i, pathNode.prevNode);\r\n      path.push(pathNode.i);\r\n      pathNode = pathNodes[pathNode.prevNode];\r\n    }\r\n    path.push(pathNode.i);\r\n    path.reverse();\r\n    this.path = path;\r\n    this.pathStepCurrent = 0;\r\n    return path;\r\n  }\r\n\r\n  getNextPathStep() {\r\n    if (this.pathStepArray[this.pathStepCurrent + 1]) {\r\n      this.pathStepCurrent += 1;\r\n      return this.pathStepArray[this.pathStepCurrent];\r\n    }\r\n    return this.pathStepArray[this.pathStepCurrent];\r\n  }\r\n}\r\n","import { PathAlgorithm, pathNode } from \"./PathAlgorithm\";\r\nimport { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport class DijkstraAlgorithm extends PathAlgorithm {\r\n  /**\r\n   * Calculates path using Dijkstra's Algorithm\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath = () => {\r\n    let { start, end, nodes } = this;\r\n    let pathNodes: pathNode[] = this.createNodeArray(nodes);\r\n    // Dijkstra's Algorithm\r\n    // Create a set of unvisited nodes called the unvisited set.\r\n    //let unvisited = new Set<number>();\r\n    let unvisited: number[] = [];\r\n    pathNodes.forEach((item, index) => {\r\n      // assign to every node a tentative distance value\r\n      // 0 for the start node, infinity for all other nodes.\r\n      if (start === index) {\r\n        item.distance = 0;\r\n      } else {\r\n        item.distance = Infinity;\r\n      }\r\n      unvisited.push(index);\r\n    });\r\n    // Set the initial node as the current node\r\n    let cNode = pathNodes[start];\r\n    while (unvisited.length > 0) {\r\n      // For the current node, go through all of it's neighbors.\r\n      let neighbours = this.getNodeNeighbours(cNode.i);\r\n      // These also prevent the esLint no-loop-func error.\r\n      let cDistance = cNode.distance;\r\n      let cIndex = cNode.i;\r\n      neighbours.forEach(index => {\r\n        // consider only unvisited neighbours. (that also aren't walls)\r\n        if (unvisited.includes(index) && pathNodes[index].weight !== 0) {\r\n          // Calculate tentative distance through the current node\r\n          let distance = pathNodes[index].weight + cDistance;\r\n          // Compare the tentative distance to the current assigned distance\r\n          // and assign the smaller one, and set the prevNode index so we can keep the path as well.\r\n          if (pathNodes[index].distance > distance) {\r\n            pathNodes[index].distance = distance;\r\n            pathNodes[index].prevNode = cIndex;\r\n          }\r\n        }\r\n      });\r\n\r\n      // Mark the current node as visited by removing it from the unvisited set.\r\n      unvisited.splice(unvisited.indexOf(cNode.i), 1);\r\n      // If destination node has been visited, then stop.\r\n      if (!unvisited.includes(end)) {\r\n        //this.buildCurrentStep(pathNodes);\r\n        this.pathNodeArray = pathNodes;\r\n        return this.buildPathArray(pathNodes);\r\n      }\r\n      // end will be infinity if it hasn't been found yet,\r\n      // so we can use it to find the next lowest distance node.\r\n      let smallestDistIndex = end; // prevents no-loop-func EsLint error that occurs if you directly use cNode.\r\n      unvisited.forEach(index => {\r\n        // select unvisited node with the smallest distance as current node.\r\n        if (pathNodes[index].distance < pathNodes[smallestDistIndex].distance) {\r\n          smallestDistIndex = index;\r\n        }\r\n      });\r\n      cNode = pathNodes[smallestDistIndex];\r\n\r\n      this.buildCurrentStep(pathNodes, unvisited, cNode);\r\n      // if the smallest distance is infinity still, there is no path, so end.\r\n      if (cNode.distance === Infinity) {\r\n        return [];\r\n      }\r\n    }\r\n    return [];\r\n  };\r\n\r\n  buildCurrentStep(\r\n    pathNodes: pathNode[],\r\n    unvisited: number[],\r\n    nextNode: pathNode\r\n  ) {\r\n    let stepNodes: GRID_ITEM_STATUS[] = pathNodes.map((node, index) => {\r\n      if (node.weight === 0) {\r\n        return GRID_ITEM_STATUS.WALL;\r\n      } else if (node.prevNode !== undefined && unvisited.includes(index)) {\r\n        return GRID_ITEM_STATUS.EXPLORING;\r\n      } else if (node.prevNode !== undefined) {\r\n        return GRID_ITEM_STATUS.EXPLORED;\r\n      }\r\n      return GRID_ITEM_STATUS.OPEN;\r\n    });\r\n\r\n    this.pathStepArray.push(stepNodes);\r\n  }\r\n}\r\n","export interface HeapData {\r\n  key: number;\r\n  value: number;\r\n}\r\n\r\n/**\r\n * Binary min kvheap\r\n * @param key keys are used to sort the array.\r\n * @param value values are stored with the key.\r\n */\r\nexport class BinaryMinHeapKV {\r\n  heap: HeapData[];\r\n  constructor() {\r\n    this.heap = [];\r\n  }\r\n\r\n  /**\r\n   * Gets parent index\r\n   * @param index\r\n   * @returns {number} parent index\r\n   */\r\n  private getParent = (index: number) => {\r\n    return Math.floor((index - 1) / 2);\r\n  };\r\n\r\n  /**\r\n   * Get index of left child of parent\r\n   * @param parent parent index\r\n   * @returns {number} left child index\r\n   */\r\n  private getLeft = (parent: number) => {\r\n    return parent * 2 + 1;\r\n  };\r\n\r\n  /**\r\n   * Get index for right child of parent\r\n   * @param parent parent index\r\n   * @returns {number} right child index\r\n   */\r\n  private getRight = (parent: number) => {\r\n    return parent * 2 + 2;\r\n  };\r\n\r\n  /**\r\n   * Swaps index1 and index2 in the heap.\r\n   * @param index1 index of heap to swap\r\n   * @param index2 index of heap to swap\r\n   */\r\n  private swap = (index1: number, index2: number) => {\r\n    let t = this.heap[index1];\r\n    this.heap[index1] = this.heap[index2];\r\n    this.heap[index2] = t;\r\n  };\r\n\r\n  /**\r\n   * Determines whether key of indexA is less than key of indexB\r\n   * @param indexA index of heap\r\n   * @param indexB index of heap to compare to\r\n   * @returns {boolean} true if A.key < B.key otherwise false.\r\n   */\r\n  private isKeyALessThanB = (indexA: number, indexB: number) => {\r\n    if (this.heap[indexA].key < this.heap[indexB].key) {\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Recursively sifts down HeapData at index until min heap is preserved\r\n   * @param index index of heap to sift down\r\n   */\r\n  private siftDown = (index: number) => {\r\n    let { heap, getLeft, getRight, isKeyALessThanB, siftDown, swap } = this;\r\n    if (index >= 0) {\r\n      let left = getLeft(index);\r\n      let right = getRight(index);\r\n      // have to check if they are undefined before comparisons.\r\n      if (heap[left] && heap[right]) {\r\n        // need to make sure at least one of them is lower before we swap...\r\n        if (isKeyALessThanB(left, index) || isKeyALessThanB(right, index)) {\r\n          // will swap right with index if left === right.\r\n          let lowerIndex = isKeyALessThanB(left, right) ? left : right;\r\n          swap(lowerIndex, index);\r\n          siftDown(lowerIndex);\r\n        }\r\n      } else if (heap[left] && isKeyALessThanB(left, index)) {\r\n        swap(left, index);\r\n        siftDown(left);\r\n      } else if (heap[right] && isKeyALessThanB(right, index)) {\r\n        swap(right, index);\r\n        siftDown(right);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Inserts key, value into binary min heap.\r\n   * @param key number used to sort binary minheap\r\n   * @param value number also stored with key.\r\n   */\r\n  public insert = (key: number, value: number) => {\r\n    let heapData: HeapData = { key: key, value: value };\r\n    this.heap.push(heapData);\r\n\r\n    let swapRecursive = (index: number) => {\r\n      let parent = this.getParent(index);\r\n      if (parent >= 0 && this.heap[parent].key > this.heap[index].key) {\r\n        this.swap(index, parent);\r\n        swapRecursive(parent);\r\n      }\r\n    };\r\n    swapRecursive(this.heap.length - 1);\r\n  };\r\n\r\n  /**\r\n   * Removes and returns the minimum value of the heap\r\n   * @returns {HeapData} {key: number, value: number} of minimum of heap.\r\n   */\r\n  public extractMin = () => {\r\n    let { heap, siftDown } = this;\r\n    let min = {\r\n      key: heap[0].key,\r\n      value: heap[0].value\r\n    };\r\n    // replace first element with last element.\r\n    heap[0] = heap[heap.length - 1];\r\n    // remove last element from heap.\r\n    heap.pop();\r\n    // sift down the first element.\r\n    siftDown(0);\r\n    return min;\r\n  };\r\n\r\n  /**\r\n   * Determines if the minheap is empty\r\n   * @returns {boolean} true or false\r\n   */\r\n  public isEmpty = () => {\r\n    if (this.heap.length > 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Determines whether value is in the heap\r\n   * @param value Value stored with key\r\n   * @returns {boolean} true or false\r\n   */\r\n  public containsValue = (value: number) => {\r\n    return this.heap.some(item => item.value === value);\r\n  };\r\n}\r\n","import { PathAlgorithm, pathNode, pathData } from \"./PathAlgorithm\";\r\nimport { BinaryMinHeapKV } from \"./BinaryMinHeapKV\";\r\nimport { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport class AStarAlgorithm extends PathAlgorithm {\r\n  endX: number;\r\n  endY: number;\r\n\r\n  constructor(data: pathData) {\r\n    super(data);\r\n\r\n    let { endX, endY } = this.getEndXY();\r\n    this.endX = endX;\r\n    this.endY = endY;\r\n  }\r\n\r\n  /**\r\n   * Calculates path using the A* algorithm.\r\n   * @param greedy Should path calculation use the greedy algorithm\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath(greedy: boolean = false) {\r\n    let { start, end, nodes } = this;\r\n    let pathNodes: pathNode[] = this.createNodeArray(nodes);\r\n\r\n    // nodes that have been explored\r\n    let closedNodes = new Set<number>();\r\n\r\n    // the cost of the cheapest path from start to n currently known\r\n    let gScore: number[] = new Array(pathNodes.length).fill(Infinity);\r\n    gScore[start] = 0;\r\n\r\n    // fScore[n] = gScores[n] + heuristic(n)\r\n    let fScore = [...gScore];\r\n    fScore[start] = this.getHeuristic(start);\r\n\r\n    // min heap of nodes that can still be explored\r\n    let minHeap = new BinaryMinHeapKV();\r\n    minHeap.insert(this.getHeuristic(start), start);\r\n\r\n    while (!minHeap.isEmpty()) {\r\n      // get lowest fscore node in minheap.\r\n      let currentNodeIndex = minHeap.extractMin().value;\r\n      let currentNode = pathNodes[currentNodeIndex];\r\n      if (currentNode.i === end) {\r\n        this.pathNodeArray = pathNodes;\r\n        return this.buildPathArray(pathNodes);\r\n      }\r\n\r\n      closedNodes.add(currentNodeIndex);\r\n      let neighbours = this.getNodeNeighbours(currentNode.i);\r\n      neighbours.forEach(neighbourIndex => {\r\n        if (closedNodes.has(neighbourIndex)) {\r\n          return;\r\n        }\r\n        // if it's not a wall.\r\n        if (pathNodes[neighbourIndex].weight !== 0) {\r\n          // Calculate a new gScore.\r\n          let newGScore =\r\n            gScore[currentNodeIndex] + pathNodes[neighbourIndex].weight;\r\n          if (newGScore < gScore[neighbourIndex]) {\r\n            // Update gscore, fScore, prevNode, and add to the openNodes array.\r\n            pathNodes[neighbourIndex].prevNode = currentNodeIndex;\r\n            gScore[neighbourIndex] = newGScore;\r\n\r\n            if (!greedy) {\r\n              // non-greedy cares about the weight to the node as well.\r\n              fScore[neighbourIndex] =\r\n                newGScore + this.getHeuristic(neighbourIndex);\r\n            } else {\r\n              // greedy only cares about the heuristic, and its weight\r\n              fScore[neighbourIndex] = this.getHeuristic(neighbourIndex);\r\n            }\r\n\r\n            // Don't need to check if minheap already contains the neighbour\r\n            // can just re-insert it instead of updating key / re-heapifying\r\n            // as it will be added to closedNodes if it's the lowest, and never added again.\r\n\r\n            minHeap.insert(fScore[neighbourIndex], neighbourIndex);\r\n            this.buildCurrentStep(closedNodes, pathNodes);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Get end's x,y position for use in algorithm.\r\n   * @returns object with endX and endY properties\r\n   */\r\n  getEndXY = () => {\r\n    let endY = Math.floor(this.end / this.columns);\r\n    let endX = this.end - endY * this.columns;\r\n    return { endX, endY };\r\n  };\r\n\r\n  /**\r\n   * Calculates the heuristic for the current index in a* algorithm by manhattan distance\r\n   * @returns Manhattan distance from index to end position.\r\n   */\r\n  getHeuristic = (index: number) => {\r\n    let y = Math.floor(index / this.columns);\r\n    let x = index - y * this.columns;\r\n    return Math.abs(this.endY - y) + Math.abs(this.endX - x);\r\n  };\r\n\r\n  buildCurrentStep(closedNodes: Set<number>, pathNodes: pathNode[]) {\r\n    let stepNodes: GRID_ITEM_STATUS[] = pathNodes.map((node, index) => {\r\n      if (node.weight === 0) {\r\n        return GRID_ITEM_STATUS.WALL;\r\n      }\r\n      if (node.prevNode !== undefined && closedNodes.has(index)) {\r\n        return GRID_ITEM_STATUS.EXPLORED;\r\n      } else if (node.prevNode !== undefined) {\r\n        return GRID_ITEM_STATUS.EXPLORING;\r\n      }\r\n      return GRID_ITEM_STATUS.OPEN;\r\n    });\r\n    this.pathStepArray.push(stepNodes);\r\n  }\r\n}\r\n","import { PathAlgorithm, pathNode, pathData } from \"./PathAlgorithm\";\r\nimport { BinaryMinHeapKV } from \"./BinaryMinHeapKV\";\r\nimport { GRID_ITEM_STATUS } from \"../Constants/enums\";\r\n\r\nexport class DualAStarAlgorithm extends PathAlgorithm {\r\n  endX: number;\r\n  endY: number;\r\n  startX: number;\r\n  startY: number;\r\n\r\n  constructor(data: pathData) {\r\n    super(data);\r\n    let endXY = this.getXYForIndex(data.end);\r\n    this.endX = endXY.x;\r\n    this.endY = endXY.y;\r\n    let startXY = this.getXYForIndex(data.start);\r\n    this.startX = startXY.x;\r\n    this.startY = startXY.y;\r\n  }\r\n\r\n  /**\r\n   * Get end's x,y position for use in algorithm.\r\n   * @returns object with endX and endY properties\r\n   */\r\n  getXYForIndex = (index: number) => {\r\n    let y = Math.floor(index / this.columns);\r\n    let x = index - y * this.columns;\r\n    return { x, y };\r\n  };\r\n\r\n  /**\r\n   * Get heuristic of dual astar algorithm\r\n   * @param toStart get Heuristic from index to start? (true) index to end? (false):\r\n   * @returns Manhattan distance from index to end point.\r\n   */\r\n  getHeuristic = (index: number, toStart: boolean) => {\r\n    let y = Math.floor(index / this.columns);\r\n    let x = index - y * this.columns;\r\n    if (toStart) {\r\n      return Math.abs(this.startY - y) + Math.abs(this.startX - x);\r\n    } else {\r\n      return Math.abs(this.endY - y) + Math.abs(this.endX - x);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Calculates path using the A* algorithm.\r\n   * @param greedy Should path calculation use the greedy algorithm\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath() {\r\n    let { start, end, nodes } = this;\r\n    let pathStartNodes = this.createNodeArray(nodes);\r\n    let pathEndNodes = this.createNodeArray(nodes);\r\n    let closedStart = new Set<number>();\r\n    let closedEnd = new Set<number>();\r\n\r\n    let gScore: number[] = new Array(pathStartNodes.length).fill(Infinity);\r\n    gScore[start] = 0;\r\n    gScore[end] = 0;\r\n    let gEnd: number[] = new Array(pathEndNodes.length).fill(Infinity);\r\n    gEnd[end] = 0;\r\n\r\n    let fScore = [...gScore];\r\n    fScore[start] = this.getHeuristic(start, false);\r\n    fScore[end] = this.getHeuristic(end, true);\r\n    let fEnd = [...gEnd];\r\n    fEnd[end] = this.getHeuristic(end, true);\r\n\r\n    let minheapEnd = new BinaryMinHeapKV();\r\n    let minheapStart = new BinaryMinHeapKV();\r\n\r\n    minheapStart.insert(fScore[start], start);\r\n    minheapEnd.insert(fScore[end], end);\r\n\r\n    while (!minheapEnd.isEmpty() && !minheapStart.isEmpty()) {\r\n      let startNodeIndex = minheapStart.extractMin().value;\r\n      let endNodeIndex = minheapEnd.extractMin().value;\r\n\r\n      let startNode = pathStartNodes[startNodeIndex];\r\n\r\n      // should also check if closedStart has endNode as well, but good enough for now.\r\n      if (closedEnd.has(startNode.i)) {\r\n        // paths have met.\r\n        // need to add end path to start path\r\n        let prev: number | undefined = pathEndNodes[startNode.i].prevNode;\r\n        let cur = startNode.i;\r\n        while (prev !== undefined && prev >= 0) {\r\n          // set start[prev]'s prev node to start[cur]\r\n          pathStartNodes[prev].prevNode = cur;\r\n          cur = prev;\r\n          prev = pathEndNodes[prev].prevNode;\r\n        }\r\n        this.pathNodeArray = pathStartNodes;\r\n        return this.buildPathArray(pathStartNodes);\r\n      }\r\n\r\n      closedEnd.add(endNodeIndex);\r\n      closedStart.add(startNodeIndex);\r\n\r\n      let neighboursStart = this.getNodeNeighbours(startNodeIndex);\r\n      let nieghboursEnd = this.getNodeNeighbours(endNodeIndex);\r\n\r\n      neighboursStart.forEach(neighbourIndex =>\r\n        this.doNeighbourCalculations(\r\n          startNodeIndex,\r\n          neighbourIndex,\r\n          closedStart,\r\n          pathStartNodes,\r\n          gScore,\r\n          fScore,\r\n          minheapStart,\r\n          false,\r\n          false\r\n        )\r\n      );\r\n\r\n      nieghboursEnd.forEach(neighbourIndex =>\r\n        this.doNeighbourCalculations(\r\n          endNodeIndex,\r\n          neighbourIndex,\r\n          closedEnd,\r\n          pathEndNodes,\r\n          gEnd,\r\n          fEnd,\r\n          minheapEnd,\r\n          false,\r\n          true\r\n        )\r\n      );\r\n\r\n      this.buildCurrentStep(\r\n        closedStart,\r\n        pathStartNodes,\r\n        closedEnd,\r\n        pathEndNodes\r\n      );\r\n    }\r\n    return [];\r\n  }\r\n\r\n  doNeighbourCalculations = (\r\n    currentNodeIndex: number,\r\n    neighbourIndex: number,\r\n    closedNodes: Set<number>,\r\n    pathNodes: pathNode[],\r\n    gScore: number[],\r\n    fScore: number[],\r\n    minHeap: BinaryMinHeapKV,\r\n    greedy: boolean,\r\n    toStart: boolean\r\n  ) => {\r\n    if (closedNodes.has(neighbourIndex)) {\r\n      return;\r\n    }\r\n    // if it's not a wall.\r\n    if (pathNodes[neighbourIndex].weight !== 0) {\r\n      // Calculate a new gScore.\r\n      let newGScore =\r\n        gScore[currentNodeIndex] + pathNodes[neighbourIndex].weight;\r\n      if (newGScore < gScore[neighbourIndex]) {\r\n        // Update gscore, fScore, prevNode, and add to the openNodes array.\r\n        pathNodes[neighbourIndex].prevNode = currentNodeIndex;\r\n        gScore[neighbourIndex] = newGScore;\r\n\r\n        if (!greedy) {\r\n          // non-greedy cares about the weight to the node as well.\r\n          fScore[neighbourIndex] =\r\n            newGScore + this.getHeuristic(neighbourIndex, toStart);\r\n        } else {\r\n          // greedy only cares about the heuristic, and its weight\r\n          fScore[neighbourIndex] = this.getHeuristic(neighbourIndex, toStart);\r\n        }\r\n        // Don't need to check if minheap already contains the neighbour\r\n        // can just re-insert it instead of updating key / re-heapifying\r\n        // as it will be added to closedNodes if it's the lowest, and never added again.\r\n        minHeap.insert(fScore[neighbourIndex], neighbourIndex);\r\n      }\r\n    }\r\n  };\r\n\r\n  buildCurrentStep(\r\n    closedNodes: Set<number>,\r\n    pathNodes: pathNode[],\r\n    closedEnd: Set<number>,\r\n    pathEnd: pathNode[]\r\n  ) {\r\n    let stepNodes: GRID_ITEM_STATUS[] = pathNodes.map((node, index) => {\r\n      if (node.weight === 0) {\r\n        return GRID_ITEM_STATUS.WALL;\r\n      }\r\n      if (node.prevNode !== undefined && closedNodes.has(index)) {\r\n        return GRID_ITEM_STATUS.EXPLORED;\r\n      } else if (node.prevNode !== undefined) {\r\n        return GRID_ITEM_STATUS.EXPLORING;\r\n      }\r\n      return GRID_ITEM_STATUS.OPEN;\r\n    });\r\n    // add path end nodes as well, overwriting other ones as needed?\r\n    pathEnd.forEach((node, index) => {\r\n      if (\r\n        node.prevNode !== undefined &&\r\n        closedEnd.has(index) &&\r\n        stepNodes[index] === GRID_ITEM_STATUS.OPEN\r\n      ) {\r\n        stepNodes[index] = GRID_ITEM_STATUS.EXPLORED;\r\n      } else if (\r\n        node.prevNode !== undefined &&\r\n        stepNodes[index] === GRID_ITEM_STATUS.OPEN\r\n      ) {\r\n        stepNodes[index] = GRID_ITEM_STATUS.EXPLORING;\r\n      }\r\n    });\r\n\r\n    this.pathStepArray.push(stepNodes);\r\n  }\r\n}\r\n","import { PATH_ALGORITHM } from \"../Constants/enums\";\r\nimport { DijkstraAlgorithm } from \"./DijkstraAlgorithm\";\r\nimport { AStarAlgorithm } from \"./AStarAlgorithm\";\r\nimport { PathAlgorithm } from \"./PathAlgorithm\";\r\nimport { DualAStarAlgorithm } from \"./DualAStarAlgorithm\";\r\nexport class Pathfinder {\r\n  nodes: number[];\r\n  start: number;\r\n  end: number;\r\n  rows: number;\r\n  columns: number;\r\n  path: number[];\r\n  pathAlgorithm: PathAlgorithm;\r\n  constructor(\r\n    nodes: number[],\r\n    rows: number,\r\n    columns: number,\r\n    start: number,\r\n    end: number\r\n  ) {\r\n    this.nodes = nodes;\r\n    this.rows = rows;\r\n    this.columns = columns;\r\n    this.start = start;\r\n    this.end = end;\r\n    this.path = [];\r\n    this.pathAlgorithm = new PathAlgorithm(this.getDataObject());\r\n  }\r\n\r\n  private getDataObject = () => {\r\n    return {\r\n      nodes: this.nodes,\r\n      rows: this.rows,\r\n      columns: this.columns,\r\n      start: this.start,\r\n      end: this.end,\r\n      path: []\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Calculates and returns the path for the specified algorithm\r\n   * @param [algorithm] Type of algorithm to use\r\n   * @returns Array of numbers representing index's of path in order.\r\n   */\r\n  calcPath(algorithm?: PATH_ALGORITHM) {\r\n    let data = this.getDataObject();\r\n    let alg;\r\n    switch (algorithm) {\r\n      case PATH_ALGORITHM.ASTAR_GREEDY:\r\n        alg = new AStarAlgorithm(data);\r\n        this.path = alg.calcPath(true);\r\n        break;\r\n      case PATH_ALGORITHM.ASTAR:\r\n        alg = new AStarAlgorithm(data);\r\n        this.path = alg.calcPath();\r\n        break;\r\n      case PATH_ALGORITHM.ASTAR_DUAL:\r\n        alg = new DualAStarAlgorithm(data);\r\n        this.path = alg.calcPath();\r\n        break;\r\n      default:\r\n        alg = new DijkstraAlgorithm(data);\r\n        this.path = alg.calcPath();\r\n        break;\r\n    }\r\n    this.pathAlgorithm = alg;\r\n    return this.path;\r\n  }\r\n\r\n  getPathNodes() {\r\n    return this.pathAlgorithm.pathNodeArray;\r\n  }\r\n\r\n  getPathSteps() {\r\n    return this.pathAlgorithm.pathStepArray;\r\n  }\r\n\r\n  getPathStepsLength() {\r\n    return this.pathAlgorithm.pathStepArray.length;\r\n  }\r\n\r\n  getNextPathStep() {\r\n    return this.pathAlgorithm.getNextPathStep();\r\n  }\r\n}\r\n","import React, { ChangeEvent } from \"react\";\r\n\r\nimport GridItem from \"../../Components/GridItem/GridItem\";\r\nimport { GRID_ITEM_STATUS, PATH_ALGORITHM } from \"../../Constants/enums\";\r\n\r\nimport \"./Grid.css\";\r\nimport { Pathfinder } from \"../../Classes/Pathfinder\";\r\nimport { pathNode } from \"../../Classes/PathAlgorithm\";\r\n\r\ntype GridProps = {\r\n  rows: number;\r\n  columns: number;\r\n};\r\n\r\n/**\r\n * @param nodes Nodes of the grid, 0 is not-walkable (ie a wall), all other values are the weight of going to that node.\r\n */\r\ntype GridState = {\r\n  nodes: number[];\r\n  path: number[];\r\n  algorithm: PATH_ALGORITHM;\r\n  isDragging: boolean;\r\n  isCreatingWalls: boolean;\r\n  dragStartIndex: number;\r\n  dragStartInitialWeight: number;\r\n  dragEndIndex: number;\r\n  pathNodes: pathNode[];\r\n  pathStep: GRID_ITEM_STATUS[];\r\n  waitTime: number;\r\n};\r\n\r\nclass Grid extends React.Component<GridProps, GridState> {\r\n  constructor(props: GridProps) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      /** Nodes of the grid, 0 is not-walkable (ie a wall), all other values are the weight of going to that node. */\r\n      nodes: new Array(props.rows * props.columns).fill(1),\r\n      path: [],\r\n      algorithm: PATH_ALGORITHM.DIJKSTRA,\r\n      isDragging: false,\r\n      isCreatingWalls: false,\r\n      dragStartInitialWeight: 0,\r\n      dragStartIndex: 0,\r\n      dragEndIndex: 0,\r\n      pathNodes: [],\r\n      pathStep: new Array(props.rows * props.columns).fill(\r\n        GRID_ITEM_STATUS.OPEN\r\n      ),\r\n      waitTime: 5\r\n    };\r\n    this.state.pathStep[0] = GRID_ITEM_STATUS.START;\r\n    this.state.pathStep[this.state.pathStep.length - 1] = GRID_ITEM_STATUS.END;\r\n    this.state.nodes[0] = -1;\r\n    this.state.nodes[this.state.nodes.length - 1] = -2;\r\n  }\r\n\r\n  componentDidUpdate(prevProps: GridProps) {\r\n    if (\r\n      this.props.columns !== prevProps.columns ||\r\n      this.props.rows !== prevProps.rows\r\n    ) {\r\n      this.resetPathState(true);\r\n    }\r\n  }\r\n\r\n  resetPathState = (resetNodes = false) => {\r\n    let nodes = new Array(this.props.rows * this.props.columns).fill(1);\r\n    nodes[0] = -1;\r\n    nodes[nodes.length - 1] = -2;\r\n    this.setState({\r\n      nodes: resetNodes ? nodes : this.state.nodes,\r\n      path: [],\r\n      pathNodes: [],\r\n      pathStep: []\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Generates grid items\r\n   * @param rows Number of rows to create\r\n   * @param columns Number of columns to create\r\n   * @returns array of grid__item 's\r\n   */\r\n  generateGridItems = (\r\n    rows: number,\r\n    columns: number,\r\n    nodes = this.state.nodes\r\n  ) => {\r\n    let gridItems = [];\r\n    for (let y = 0; y < rows; y++) {\r\n      for (let x = 0; x < columns; x++) {\r\n        let i = y * columns + x;\r\n        let status = this.state.pathStep[i];\r\n        if (this.state.path.includes(i)) {\r\n          status = GRID_ITEM_STATUS.PATH;\r\n        }\r\n        if (nodes[i] === 0) {\r\n          status = GRID_ITEM_STATUS.WALL;\r\n        }\r\n        if (nodes[i] === -1) {\r\n          status = GRID_ITEM_STATUS.START;\r\n        }\r\n        if (nodes[i] === -2) {\r\n          status = GRID_ITEM_STATUS.END;\r\n        }\r\n        gridItems.push(\r\n          <div className=\"item__container--square\" key={\"ics\" + x + \"_\" + y}>\r\n            <GridItem\r\n              status={status}\r\n              key={\"gi_\" + x + \"_\" + y}\r\n              row={y}\r\n              column={x}\r\n              weight={nodes[y * columns + x] ? nodes[y * columns + x] : 0}\r\n              index={y * columns + x}\r\n              displayWeight={columns > 7 && rows > 7 ? false : true}\r\n              onChange={this.onChangeNodeWeight}\r\n              onMouseEnterGridItem={this.onMouseEnterGridItem}\r\n              onMouseDownGridItem={this.onMouseDownGridItem}\r\n              onMouseUpGridItem={this.onMouseUpGridItem}\r\n              onTouchMove={this.onTouchMoveGridItem}\r\n              onTouchEnd={this.onTouchEndGridItem}\r\n            />\r\n          </div>\r\n        );\r\n      }\r\n    }\r\n    return gridItems;\r\n  };\r\n\r\n  /**\r\n   * Changes node at index to e.target.value\r\n   * @param index index of element in nodes array\r\n   */\r\n  onChangeNodeWeight = (index: number) => (\r\n    e: React.ChangeEvent<HTMLInputElement>\r\n  ) => {\r\n    let newNodes = [...this.state.nodes];\r\n    newNodes[index] = parseInt(e.target.value);\r\n    this.setState({ nodes: newNodes });\r\n  };\r\n\r\n  /**\r\n   * Set waitTime state of grid\r\n   * @param val Value to set waitTime to\r\n   */\r\n  setWaitTime = (val: number) => {\r\n    this.setState(state => {\r\n      return { waitTime: val };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Gets grid styles\r\n   * @param rows number of rows\r\n   * @param columns number of columns\r\n   * @returns  React.CSSProperties { width, height, gridTemplateColumns, gridTemplateRows }\r\n   */\r\n  getGridStyles = (rows: number, columns: number) => {\r\n    let style = this.getGridTemplate(columns);\r\n    Object.assign(style, this.calcGridHeightAndWidth(rows, columns));\r\n    return style;\r\n  };\r\n\r\n  /**\r\n   * Calcs grid height and width\r\n   * @param rows numbers of rows\r\n   * @param columns number of columns\r\n   * @returns React.CSSProperties { width: value, height: value } as % of it's container to keep each grid item a square.\r\n   */\r\n  calcGridHeightAndWidth = (rows: number, columns: number) => {\r\n    let width = 100;\r\n    let height = 100;\r\n    if (rows > columns) {\r\n      width = (columns / rows) * 100;\r\n    } else {\r\n      height = (rows / columns) * 100;\r\n    }\r\n    let gridWidth: React.CSSProperties = {\r\n      width: width + \"%\",\r\n      height: height + \"%\"\r\n    };\r\n    return gridWidth;\r\n  };\r\n\r\n  /**\r\n   * Gets grid template\r\n   * @param columns number of columns\r\n   * @returns React.CSSProperties { gridTemplateColumns: value, gridTemplateRows: value }\r\n   */\r\n  getGridTemplate = (columns: number) => {\r\n    let templateColumns = \"\";\r\n    for (let i = 0; i < columns; i++) {\r\n      templateColumns += \"1fr \";\r\n    }\r\n    let gridTemplate: React.CSSProperties = {\r\n      gridTemplateColumns: templateColumns\r\n    };\r\n    return gridTemplate;\r\n  };\r\n\r\n  /**\r\n   * Uses pathfinder.js and the state of the grid to\r\n   * calculate a path and display it.\r\n   */\r\n  onCalculatePath = () => {\r\n    this.resetPathState();\r\n    if (this.state.nodes.includes(-1) && this.state.nodes.includes(-2)) {\r\n      let pathfinder = new Pathfinder(\r\n        this.state.nodes,\r\n        this.props.rows,\r\n        this.props.columns,\r\n        this.state.nodes.indexOf(-1),\r\n        this.state.nodes.indexOf(-2)\r\n      );\r\n      let path = pathfinder.calcPath(this.state.algorithm);\r\n      let pathNodes = pathfinder.getPathNodes();\r\n      this.setState({ path: path, pathNodes: pathNodes });\r\n    }\r\n  };\r\n\r\n  onCalculatePathSteps = () => {\r\n    this.resetPathState();\r\n    if (this.state.nodes.includes(-1) && this.state.nodes.includes(-2)) {\r\n      let pathfinder = new Pathfinder(\r\n        this.state.nodes,\r\n        this.props.rows,\r\n        this.props.columns,\r\n        this.state.nodes.indexOf(-1),\r\n        this.state.nodes.indexOf(-2)\r\n      );\r\n      pathfinder.calcPath(this.state.algorithm);\r\n      this.DisplayPathSteps(pathfinder);\r\n    }\r\n  };\r\n\r\n  async DisplayPathSteps(pathfinder: Pathfinder) {\r\n    let steps = pathfinder.getPathStepsLength();\r\n    let path = pathfinder.path;\r\n    for (let i = 0; i < steps; i++) {\r\n      this.setState({ pathStep: pathfinder.getNextPathStep() });\r\n      await this.wait(this.state.waitTime);\r\n    }\r\n    this.setState({ path: path });\r\n  }\r\n\r\n  wait = (ms: number) => new Promise(res => setTimeout(res, ms));\r\n\r\n  /**\r\n   * Changes the algorithm state based on select elements value.\r\n   */\r\n  onChangeAlgorithm = (e: ChangeEvent<HTMLSelectElement>) => {\r\n    this.setState({ algorithm: parseInt(e.target.value) });\r\n  };\r\n\r\n  /**\r\n   * Sets is dragging to false, and the dragEndIndex to index.\r\n   * Changes the node at index to a wall or open if that nodes weight wasn't\r\n   * changed between MouseDown & MouseUp.\r\n   * @param index index of node array that mouseup event was called on.\r\n   */\r\n  stopDragAt = (index: number) => {\r\n    // it was a mouse click\r\n    if (\r\n      this.state.dragStartIndex === index &&\r\n      this.state.dragStartInitialWeight === this.state.nodes[index]\r\n    ) {\r\n      let nodes = [...this.state.nodes];\r\n      let tempVal = nodes[index] - 1;\r\n      // make sure we dont go below start/end markers\r\n      if (tempVal < -2) {\r\n        //set end node to last node\r\n        tempVal = 1;\r\n        nodes[nodes.length - 1] = -2;\r\n      } else if (tempVal === -2) {\r\n        // is making an end node, need a new start node, set to first node, clear current end node.\r\n        nodes[nodes.indexOf(-2)] = 1;\r\n        nodes[0] = -1;\r\n      } else if (tempVal === -1) {\r\n        // new start node, clear previous start node.\r\n        nodes[nodes.indexOf(-1)] = 1;\r\n      }\r\n      nodes[index] = tempVal;\r\n\r\n      this.setState(state => {\r\n        return {\r\n          isDragging: false,\r\n          dragEndIndex: index,\r\n          nodes: nodes\r\n        };\r\n      });\r\n    } else {\r\n      // it was actually a drag.\r\n      this.setState(state => {\r\n        return { isDragging: false, dragEndIndex: index };\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sets isdragging state to false\r\n   * Used for when mouse exits grid area on drag,\r\n   * or if touch event ends.\r\n   */\r\n  stopDrag = () => {\r\n    // Would need an index to call stopDragAt, which would need a\r\n    // last updated index state.\r\n    this.setState(state => {\r\n      return { isDragging: false };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Updates state of isDragging to true, dragStartIndex to index,\r\n   * dragStartInitialWeight to node at index's weight,\r\n   * sets isCreatingWalls state based on node at index's weight\r\n   * @param index index in node array that mousedown was called on.\r\n   */\r\n  startDragAt = (index: number) => {\r\n    this.resetPathState();\r\n    this.setState(state => {\r\n      return {\r\n        isDragging: true,\r\n        dragStartIndex: index,\r\n        dragStartInitialWeight: this.state.nodes[index],\r\n        isCreatingWalls: this.state.nodes[index] === 0 ? false : true\r\n      };\r\n    });\r\n  };\r\n\r\n  /**\r\n   * If user is dragging, changes node weight to 0 or 1\r\n   * depending on if they started dragging on a wall or open node,\r\n   * and updates the node state.\r\n   * @param index index in node array that mouse entered\r\n   */\r\n  continueDragAt = (index: number) => {\r\n    if (this.state.isDragging) {\r\n      if (\r\n        index !== this.state.dragStartIndex &&\r\n        this.state.nodes[index] !== -1 &&\r\n        this.state.nodes[index] !== -2\r\n      ) {\r\n        // User is dragging, so switch between walls & open tiles.\r\n        let nodes = [...this.state.nodes];\r\n        nodes[index] = this.state.isCreatingWalls ? 0 : 1;\r\n\r\n        nodes[this.state.dragStartIndex] = nodes[index];\r\n        this.setState(state => {\r\n          return { nodes: nodes };\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Update drag state variables on mouse down.\r\n   * @param index index in node array that mousedown was called on.\r\n   */\r\n  onMouseDownGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.startDragAt(index);\r\n    if (e.target === e.currentTarget) {\r\n      e.preventDefault();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Update drag state on mouse up.\r\n   * @param index index of node array that mouseup event was called on.\r\n   */\r\n  onMouseUpGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.stopDragAt(index);\r\n  };\r\n\r\n  /**\r\n   * Upgrade node state on mouse enter\r\n   * @param index index in node array that mouse entered\r\n   */\r\n  onMouseEnterGridItem = (index: number) => (e: React.MouseEvent) => {\r\n    this.continueDragAt(index);\r\n  };\r\n\r\n  /**\r\n   * Sets state of dragging to false\r\n   */\r\n  onMouseExitGrid = (e: React.MouseEvent) => {\r\n    this.stopDrag();\r\n  };\r\n\r\n  /**\r\n   * Updates state for nodes & dragging based on element touch is over.\r\n   */\r\n  onTouchMoveGridItem = (e: React.TouchEvent) => {\r\n    let el = document.elementFromPoint(\r\n      e.touches[0].clientX,\r\n      e.touches[0].clientY\r\n    );\r\n    // need to make sure we have a valid element & valid data.\r\n    if (el !== null) {\r\n      let data = el.getAttribute(\"data-index\");\r\n      if (data !== null) {\r\n        let index = parseInt(data);\r\n        if (this.state.isDragging === false) {\r\n          this.startDragAt(index);\r\n        } else {\r\n          this.continueDragAt(index);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sets is dragging state to false.\r\n   */\r\n  onTouchEndGridItem = (e: React.TouchEvent) => {\r\n    this.stopDrag();\r\n  };\r\n\r\n  render() {\r\n    const { rows, columns } = this.props;\r\n    const { nodes, waitTime } = this.state;\r\n    return (\r\n      <>\r\n        <div\r\n          className=\"grid__container\"\r\n          style={this.getGridStyles(rows, columns)}\r\n          onMouseLeave={this.onMouseExitGrid}\r\n        >\r\n          {this.generateGridItems(rows, columns, nodes)}\r\n        </div>\r\n        <div className=\"grid__flexContainer\">\r\n          <div className=\"flex__innerContainer\">\r\n            <button\r\n              id=\"calc_path\"\r\n              className=\"flex__button\"\r\n              onClick={this.onCalculatePath}\r\n            >\r\n              Calculate Path\r\n            </button>\r\n            <button\r\n              id=\"calc_path_steps\"\r\n              className=\"flex__button\"\r\n              onClick={this.onCalculatePathSteps}\r\n            >\r\n              Show Path Steps\r\n            </button>\r\n          </div>\r\n          <div className=\"flex__innerContainer\">\r\n            <div className=\"input__container\">\r\n              <label htmlFor=\"select_algorithm\">Algorithm:</label>\r\n              <select\r\n                id=\"select_algorithm\"\r\n                className=\"input__item\"\r\n                onChange={this.onChangeAlgorithm}\r\n              >\r\n                <option value={PATH_ALGORITHM.DIJKSTRA}>Dijkstra</option>\r\n                <option value={PATH_ALGORITHM.ASTAR}>A*</option>\r\n                <option value={PATH_ALGORITHM.ASTAR_GREEDY}>A* Greedy</option>\r\n                <option value={PATH_ALGORITHM.ASTAR_DUAL}>Dual A*</option>\r\n              </select>\r\n            </div>\r\n            <div className=\"input__container\">\r\n              <label htmlFor=\"waitTime\">Step Delay Time:</label>\r\n              <input\r\n                id=\"waitTime\"\r\n                className=\"input__item\"\r\n                type=\"number\"\r\n                min={3}\r\n                value={waitTime}\r\n                onChange={e => this.setWaitTime(parseInt(e.target.value))}\r\n              />\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Grid;\r\n","import React, { useState } from \"react\";\r\n\r\nimport Grid from \"./Containers/Grid/Grid\";\r\n\r\nimport \"./App.css\";\r\n\r\nconst App: React.FC = () => {\r\n  const [rows, setRows] = useState(8);\r\n  const [columns, setColumns] = useState(8);\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"app__container\">\r\n        <div className=\"app__inputContainer\">\r\n          <div className=\"input__container\">\r\n            <label htmlFor=\"rows\">Rows:</label>\r\n            <input\r\n              id=\"rows\"\r\n              className=\"input__item\"\r\n              type=\"number\"\r\n              min={3}\r\n              value={rows}\r\n              onChange={e =>\r\n                parseInt(e.target.value) > 0\r\n                  ? setRows(parseInt(e.target.value))\r\n                  : setRows(1)\r\n              }\r\n            />\r\n          </div>\r\n          <div className=\"input__container\">\r\n            <label htmlFor=\"columns\">Columns:</label>\r\n            <input\r\n              id=\"rows\"\r\n              className=\"input__item\"\r\n              type=\"number\"\r\n              min={3}\r\n              value={columns}\r\n              onChange={e =>\r\n                parseInt(e.target.value) > 0\r\n                  ? setColumns(parseInt(e.target.value))\r\n                  : setColumns(1)\r\n              }\r\n            />\r\n          </div>\r\n        </div>\r\n        <Grid rows={rows} columns={columns} />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}